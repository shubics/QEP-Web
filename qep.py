"""
QEPlotter — Quantum ESPRESSO Band and Fatband Visualization Toolkit
===================================================================

QEPlotter is an open-source, user-friendly Python library for visualizing
band structures and fatbands from Quantum ESPRESSO calculations.

Key Features:
-------------
- Read and plot Quantum ESPRESSO band structure files (.bands.dat.gnu), k-point paths, and fatband/projwfc files.
- Support for multiple fatband coloring and grouping modes:
    * By atom (element-projected)
    * By orbital (s, p, d, etc.)
    * By element-orbital channel
- Automatic detection of band path segments and high-symmetry points.
- Total DOS and projected DOS plotting.
- All plots are automatically saved in a user-defined format (PNG, PDF, ...), organized in a "saved" folder.
- Easy integration in Python scripts or Jupyter notebooks.

Typical Usage:
--------------
from qeplotter import plot_from_file

plot_from_file(
    plot_type='fatbands',
    band_file='bands.dat.gnu',
    fatband_dir='fatband_dir',
    kpath_file='kpath.in',
    fatbands_mode='atomic',
    savefig='my_fatband.pdf'
)

Requirements:
-------------
- numpy
- matplotlib


"""

import os
import glob
import re
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.collections as mcoll


def strip_number(atom_label):
    return re.sub(r"\d+$", "", atom_label)

# ==============================
# K-POINTS / BAND READING UTILS
# ==============================

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
SCRIPT_DIR = os.path.dirname(SCRIPT_DIR)
def parse_kpath_file(kpath_file):
    """
    Parses a Quantum ESPRESSO K_POINTS (crystal_b) file to extract the number of k-points
    for each path segment and the corresponding high-symmetry point labels.

    Parameters
    ----------
    kpath_file : str
        Path to the QE K_POINTS file (crystal_b format).

    Returns
    -------
    counts : list of int
        Number of k-points for each segment (i.e., between high-symmetry points).
    labels : list of str
        List of high-symmetry point labels in the path (e.g., 'G', 'K', 'M').

    Notes
    -----
    The function skips the last row of the K_POINTS file. This is intentional:
      - The last row typically only repeats the initial high-symmetry point to close the band path.
      - If you do NOT skip the last row, the code would count one more segment than actually exists,
        which leads to tick and segment misalignment in plotting.

    Example
    -------
    Given a file like:
        K_POINTS crystal_b
        4
          0.0000  0.0000  0.0  20  ! G
          0.5000  0.0000  0.0  30  ! M
          0.3333  0.3333  0.0  40  ! K
          0.0000  0.0000  0.0  20  ! G
    Output will be:
        counts = [20, 30, 40]
        labels = ['G', 'M', 'K']
    """
    counts, labels = [], []
    with open(kpath_file, 'r') as f:
        lines = f.readlines()
    start = None
    for i, line in enumerate(lines):
        if line.strip().upper().startswith('K_POINTS'):
            start = i + 2
            break
    if start is None or start >= len(lines):
        raise ValueError(f"K_POINTS header not found or invalid in {kpath_file}")
    n_lines = len(lines[start:])
    for idx, line in enumerate(lines[start:]):

        if idx == n_lines - 1:
            continue
        txt = line.strip()
        if not txt or txt.startswith('#'):
            continue
        parts = txt.split('!')
        vals = parts[0].split()
        try:
            cnt = int(vals[3])
        except Exception:
            cnt = 1
        lbl = parts[1].strip() if len(parts) > 1 else ''
        counts.append(cnt)
        labels.append(lbl)
    return counts, labels


def read_band_xdistances(band_file, kpath_file):
    """
    Reads a Quantum ESPRESSO .bands.dat.gnu band file and a K_POINTS path file,
    and extracts all x-axis distances, band energies, tick locations, and segment ranges for plotting.

    Parameters
    ----------
    band_file : str
        Path to the QE .bands.dat.gnu file (typically generated by bands.x).
    kpath_file : str
        Path to the QE K_POINTS file in crystal_b format (see parse_kpath_file).

    Returns
    -------
    x_dist : np.ndarray, shape (N_k,)
        Distance along the k-path for each k-point (for x-axis).
    band_energies : np.ndarray, shape (N_bands, N_k)
        Energies for all bands at each k-point.
    tick_positions : list of float
        x-coordinates of high-symmetry points (used for vertical tick lines).
    tick_labels : list of str
        Corresponding labels for each tick (e.g., 'G', 'K', 'M', ...).
    seg_ranges : list of (int, int)
        Index ranges (start, end) for each band path segment.

    How it works
    ------------
    - The .bands.dat.gnu file consists of blocks of numbers separated by empty lines.
      Each block represents a single band: the first column is the x-distance,
      the second is the band energy at each k-point along the path.
    - All band blocks must contain the same number of k-points (N_k).
    - The k-path file provides the number of k-points in each segment, and the
      names of the high-symmetry points (see parse_kpath_file).

    Special Notes
    -------------
    - If the total k-point count in the bands file and the k-path file does not match,
      the function tries to correct for off-by-one errors, but will print a warning if mismatched.
    - If the input files are inconsistent (e.g., wrong path or missing data), a ValueError is raised.

    Example
    -------
    (Suppose .bands.dat.gnu encodes 90 k-points and 12 bands, kpath_file gives three segments.)

    x_dist, band_energies, tick_positions, tick_labels, seg_ranges = read_band_xdistances(
        band_file='bands.dat.gnu', kpath_file='kpath.in'
    )

    # x_dist: 1D numpy array of shape (90,)
    # band_energies: 2D array of shape (12, 90)
    # tick_positions: list of floats (one for each high-symmetry point)
    # tick_labels:    list of labels ('G', 'K', ...)
    # seg_ranges:     list of (start, end) index pairs for each path segment
    """
    # 1) read all lines and group into blocks
    with open(band_file, 'r') as f:
        raw = f.read().splitlines()
    blocks = []
    block = []
    for line in raw:
        if line.strip() == "":
            if block:
                blocks.append(block)
                block = []
        else:
            block.append(line)
    if block:
        blocks.append(block)

    # 2) parse each block
    band_arrays = []
    for blk in blocks:
        try:
            arr = np.loadtxt(blk)
        except Exception as e:
            raise ValueError(f"Failed to parse band block: {e}")
        if arr.ndim != 2 or arr.shape[1] < 2:
            raise ValueError(f"Unexpected block shape {arr.shape}")
        band_arrays.append(arr)

    if not band_arrays:
        raise ValueError(f"No bands found in {band_file}")

    # 3) ensure all blocks have same length
    lengths = [b.shape[0] for b in band_arrays]
    if len(set(lengths)) != 1:
        raise ValueError(f"Inconsistent k-points per band: {lengths}")
    N_k = lengths[0]

    # 4) extract x_dist and energies
    x_dist = band_arrays[0][:, 0].copy()
    band_energies = np.vstack([b[:, 1] for b in band_arrays])


    # 5) parse kpath
    counts, labels = parse_kpath_file(kpath_file)
    cum = np.cumsum([0] + counts)
    if cum[-1] != N_k:
        # adjust only by ±1, else warn
        if cum[-1] == N_k + 1:
            cum[-1] = N_k
        elif cum[-1] == N_k - 1:
            cum = np.append(cum, N_k)
            labels = labels + [labels[0] if labels else ""]
        else:
            print(f"Warning: sum(counts)={cum[-1]} != N_k={N_k}. Tick positions may be misaligned.")

    tick_positions = []
    tick_labels = []
    for idx, lbl in zip(cum, labels + [""]):
        if idx >= N_k:
            break
        tick_positions.append(x_dist[idx])
        tick_labels.append(lbl)

    # segment boundaries
    dx = np.diff(x_dist)
    breaks = np.where(dx < -1e-6)[0]
    seg_ranges = []
    start = 0
    for br in breaks:
        seg_ranges.append((start, br))
        start = br + 1
    seg_ranges.append((start, N_k - 1))

    return x_dist, band_energies, tick_positions, tick_labels, seg_ranges
# FATBAND FILE READING
# ==============================

def read_fatband_files(fatband_dir,spin=False,sub_orb=False):
    """
    Reads fatband/PDOS files from a directory and extracts labels and weights.

    Parameters
    ----------
    fatband_dir : str
        Directory containing PDOS/fatband files.
    spin : bool
        If True, looks for SOC filenames with j/mj info.
    sub_orb : bool
        If True, splits into sub-orbitals (m-resolved).
    """

    if spin:
        pattern = re.compile(r'atm#(\d+)\(([A-Za-z]+)\)_wfc#\d+\(([spdfgpxyz]+)(?:_j[0-9.]+)?\)')
        fallback = re.compile(r'atm#\d+\(([A-Za-z]+)\)_wfc#\d+\(([spdfgpxyz]+)(?:_j[0-9.]+)?\)')
    else:
        pattern = re.compile(r'atm#(\d+)\(([A-Za-z]+)\)_wfc#\d+\(([spdfgpxyz]+)\)')
        fallback = re.compile(r'atm#\d+\(([A-Za-z]+)\)_wfc#\d+\(([spdfgpxyz]+)\)')

    file_list = sorted(glob.glob(os.path.join(fatband_dir, '*pdos*')))
    if not file_list:
        raise FileNotFoundError(f"No fatband files matching '*pdos*' found in {fatband_dir}")

    labels = []
    W_list = []
    ik0 = E0 = None
    N_k = N_e = None

    # 2) read and optionally split weights
    for fn in file_list:
        base = os.path.basename(fn)
        m = pattern.search(base)
        if m:
            atom_num, elem, orb = m.groups()
            atom_label = f"{elem}{atom_num}"
        else:
            m2 = fallback.search(base)
            if m2:
                elem, orb = m2.groups()
                atom_label = elem
            else:
                orb = '?'
                atom_label = base

        data = np.loadtxt(fn, comments='#')
        if data.ndim != 2 or data.shape[1] < 3:
            raise ValueError(f"File {fn} needs ≥3 columns (got {data.shape})")

        ik = data[:, 0].astype(int)
        E = data[:, 1]

        # record grid dims on first file
        if ik0 is None:
            ik0, E0 = ik.copy(), E.copy()
            uniq_k = np.unique(ik0)
            N_k = len(uniq_k)
            counts = [np.count_nonzero(ik0 == k) for k in uniq_k]
            # allow truncation if ragged
            if not all(c == counts[0] for c in counts):
                N_e = min(counts)
                print(f"Warning: varying rows per k in {fn}; truncating to N_e={N_e}")
            else:
                N_e = counts[0]
        else:
            # validate subsequent files
            uniq_i = np.unique(ik)
            if len(uniq_i) != N_k:
                raise ValueError(f"File {fn}: unique k count {len(uniq_i)} != expected {N_k}")
            counts_i = [np.count_nonzero(ik == k) for k in uniq_i]
            if not all(c == counts_i[0] for c in counts_i):
                min_e = min(counts_i)
                print(f"Warning: {fn} has varying rows per k; truncating to {min_e}")
                N_e = min(N_e, min_e)
            elif counts_i[0] != N_e:
                N_e = min(N_e, counts_i[0])

        # choose weight columns
        if not sub_orb:
            # 1) Klasik toplam orbital ağırlığı
            w = data[:, 2]
            labels.append((atom_label, orb))
            W_list.append((ik, E, w))

        else:
            ncols = data.shape[1]

            # ---------- SOC (spin=True) dosyaları ----------
            if spin:
                # Dosya adından j değerini çek (örn. "_j1.5")
                m_j = re.search(r'_j([0-9.]+)', base)
                jtag = f"_j{m_j.group(1)}" if m_j else ""

                # k-indeksi, E ve LDOS -> ilk 3 sütun
                pdos_cols = list(range(3, ncols))
                nsub = len(pdos_cols)

                # Varsayılan etiketler (QE sıra­sı: ↑↑ ↓↓ ↑↓_Re ↑↓_Im)
                default_names = ['upup', 'downdown', 'updown_re', 'updown_im']
                subs = [f"{orb}{jtag}_{default_names[i] if i < 4 else f'c{i + 1}'}"
                        for i in range(nsub)]
                cols = pdos_cols

            # ---------- SOC’suz (spin=False) dosyalar ----------
            else:
                nsub = ncols - 2  # LDOS sonrası sütun sayısı

                if orb == 's' and nsub >= 1:
                    cols, subs = ([3], ['s']) if ncols >= 4 else ([2], ['s'])

                elif orb == 'p' and nsub >= 3:
                    cols, subs = [3, 4, 5], ['px', 'py', 'pz']

                elif orb == 'd' and nsub >= 5:
                    cols = [3, 4, 5, 6, 7][:nsub]
                    subs = ['dxy', 'dyz', 'dz2', 'dxz', 'dx2-y2'][:nsub]

                else:  # güvenli geriye dönüş
                    cols, subs = [2], [orb]

            # --------------- Sütunları kaydet ----------------
            for col, sub in zip(cols, subs):
                w = data[:, col]
                labels.append((atom_label, sub))
                W_list.append((ik, E, w))

    # 3) build E_grid and W_grids
    uniq_k = np.unique(ik0)
    E_grid = np.zeros((N_k, N_e))
    for i, kpt in enumerate(uniq_k):
        idxs = np.where(ik0 == kpt)[0][:N_e]
        E_grid[i, :] = E0[idxs]

    W_grids = []
    for ik, E, w in W_list:
        arr = np.zeros((N_k, N_e))
        for i, kpt in enumerate(uniq_k):
            idxs = np.where(ik == kpt)[0][:N_e]
            arr[i, :] = w[idxs]
        W_grids.append(arr)

    return labels, uniq_k, E_grid, W_grids


# ==============================
# PLOTTING FUNCTIONS
# ==============================

def overlay_band_plot(
    band_file1, kpath_file1, band_file2, kpath_file2,
    fermi_level=None, shift_fermi=False,
    y_range=None, dpi=None, color1='red', color2='blue',
    label1='Band1', label2='Band2',
    save_dir="saved", savefig=None
):
    """
    Overlay two band structures on the same plot.

    Parameters
    ----------
    ...
    save_dir : str, optional
        Directory where the plot should be saved. Default is "saved".
    savefig : str, optional
        Filename to save the plot.
    """
    x1, bands1, ticks1, labels1, segs1 = read_band_xdistances(band_file1, kpath_file1)
    x2, bands2, ticks2, labels2, segs2 = read_band_xdistances(band_file2, kpath_file2)

    if shift_fermi and fermi_level is not None:
        bands1 = bands1 - fermi_level
        bands2 = bands2 - fermi_level

    plt.figure(figsize=(8,6) if dpi is None else (8,6), dpi=dpi)

    for i, band in enumerate(bands1):
        for (s, e) in segs1:
            plt.plot(x1[s:e+1], band[s:e+1], color=color1, lw=1, alpha=0.85, label=label1 if i == 0 else None)
    for i, band in enumerate(bands2):
        for (s, e) in segs2:
            plt.plot(x2[s:e+1], band[s:e+1], color=color2, lw=1, alpha=0.85, label=label2 if i == 0 else None)

    for tx in ticks1:
        plt.axvline(tx, color='gray', ls='--', alpha=0.5)
    plt.xticks(ticks1, labels1)
    plt.xlabel('K-point Path')
    
    ylabel = 'E - E_F (eV)' if (shift_fermi and fermi_level is not None) else 'Energy (eV)'
    plt.ylabel(ylabel)

    if y_range:
        plt.ylim(y_range)
    if fermi_level is not None:
        y0 = 0.0 if shift_fermi else fermi_level
        plt.axhline(y0, color='r', ls='--', lw=1.2, label=f'Fermi = {fermi_level:.2f} eV')
    plt.grid(True, ls='--', alpha=0.4)
    plt.legend()
    plt.tight_layout()
    plt.title("Overlayed Band Structures")

    # --- Kaydetme kısmı ---
    def sanitize(s):
        return re.sub(r'\W+', '_', s).strip('_')
    
    if savefig:
        filename = savefig
    else:
        filename = f"BandStructure_{sanitize(label1)}_vs_{sanitize(label2)}.png"
        
    if not os.path.exists(save_dir):
        os.makedirs(save_dir)
    full_path = os.path.join(save_dir, filename)
    plt.savefig(full_path, dpi=dpi, bbox_inches='tight')
    print(f"Plot saved as {full_path}")

    plt.show()


def plot_band(
    band_file,
    kpath_file,
    fermi_level=None,
    shift_fermi=False,
    y_range=None,
    dpi=None,
    band_mode='normal',
    fatband_dir=None,
    cmap_name='tab10',
        save_dir="saved",
        savefig=None, 
        spin=False
    ,sub_orb=False
):
    """
       Plot the electronic band structure from Quantum ESPRESSO.

       Parameters
       ----------
       band_file : str
           Path to the QE band structure file (.bands.dat.gnu).
       kpath_file : str
           Path to the K_POINTS (crystal_b) file (for k-path and symmetry labels).
       fermi_level : float, optional
           Fermi energy (in eV). If given, can shift the energy axis.
       shift_fermi : bool, optional
           If True, shifts all energies so the Fermi level is at 0 eV.
       y_range : tuple or list, optional
           (ymin, ymax) limits for the energy axis.
       dpi : int, optional
           Output resolution (dots per inch) for the plot.
       band_mode : str, optional
           Plot style:
             - 'normal': plain band lines (default)
             - 'atomic', 'orbital', 'element_orbital', 'most': color bands by dominant channel
           If using a colored mode, fatband_dir must be provided.
       fatband_dir : str, optional
           Directory with projection (fatband) files, required for colored band modes.
       cmap_name : str, optional
           Name of the matplotlib colormap for colored bands.
       save_dir : str, optional
           Directory where the plot should be saved. Default is "saved".
       savefig : str, optional
           Filename for saving the plot. If None, the plot is only displayed.

       Returns
       -------
       None. Displays (and optionally saves) the band structure plot.
       """
    # 1) Read band data
    x_dist, band_energies, tick_positions, tick_labels, seg_ranges = read_band_xdistances(band_file, kpath_file)
    N_k = x_dist.shape[0]

    if shift_fermi and fermi_level is not None:
        band_energies = band_energies - fermi_level


    if dpi is not None:
        plt.figure(figsize=(8,6), dpi=dpi)
    else:
        plt.figure(figsize=(8,6))


    if band_mode == 'normal' or band_mode is None:
        for band in band_energies:
            for (s,e) in seg_ranges:
                if e > s:
                    plt.plot(x_dist[s:e+1], band[s:e+1], 'k-', lw=1)
                else:
                    plt.plot(x_dist[s], band[s], 'k.', markersize=2)
        title = 'Band Structure'
    else:

        if fatband_dir is None:
            raise ValueError(f"band_mode='{band_mode}' requires fatband_dir with projection files")
        # 2) Read fatband projection grids
        labels, uniq_ik, E_grid, W_grids = read_fatband_files(fatband_dir,spin,sub_orb)

        if len(uniq_ik) != N_k:
            print(f"Warning: fatband N_k={len(uniq_ik)} vs band file N_k={N_k}. They should match for correct coloring.")

          # strip off the atom numbers so all 'Bi1','Bi2',... become just 'Bi'
        ch_labels = [f"{a}-{o}" for (a, o) in labels]
        elems = [a for (a, _) in labels]
        orbs  = [o for (_,o) in labels]

        if band_mode == 'atomic':
            unique_keys = sorted(set(elems))

            group_indices = {key: [i for i,a in enumerate(elems) if a==key] for key in unique_keys}
        elif band_mode == 'orbital':
            unique_keys = sorted(set(orbs))
            group_indices = {key: [i for i,o in enumerate(orbs) if o==key] for key in unique_keys}
        elif band_mode in ('element_orbital', 'most'):
            unique_keys = sorted(set(ch_labels))
            group_indices = {key: [i for i,lab in enumerate(ch_labels) if lab==key] for key in unique_keys}
        else:
            raise ValueError(f"Unknown band_mode: {band_mode}")

        # 3) For each band, determine dominant group:
        nbands = band_energies.shape[0]
        band_colors = [None]*nbands

        cmap = cm.get_cmap(cmap_name, len(unique_keys))

        for b in range(nbands):

            group_sums = {key: 0.0 for key in unique_keys}

            k_iter = min(N_k, E_grid.shape[0])
            for i in range(k_iter):
                Eb = band_energies[b,i]

                if shift_fermi and fermi_level is not None:
                    row = E_grid[i,:] - fermi_level
                else:
                    row = E_grid[i,:]

                if row.size == 0:
                    continue
                j = np.argmin(np.abs(row - Eb))

                for key, idx_list in group_indices.items():

                    try:
                        wvals = [W_grids[idx][i,j] for idx in idx_list]
                    except Exception:

                        continue
                    group_sums[key] += np.sum(wvals)

            sums = np.array([group_sums[k] for k in unique_keys])
            if sums.sum() <= 0:
                color = 'k'
            else:
                imax = np.argmax(sums)
                color = cmap(imax)
            band_colors[b] = color

        # 4) Plot each band with its color
        for b, band in enumerate(band_energies):
            col = band_colors[b]
            for (s,e) in seg_ranges:
                if e > s:
                    y = band[s:e+1]
                    x = x_dist[s:e+1]
                    plt.plot(x, y, color=col, lw=1)
                else:
                    plt.plot(x_dist[s], band[s], 'o', color=col, markersize=3)
        title = f'Band Structure ({band_mode})'


        for i, key in enumerate(unique_keys):
            plt.plot([], [], color=cmap(i), label=key, lw=3)
        plt.legend(fontsize='small', ncol=2, loc='best')


    for tx in tick_positions:
        plt.axvline(tx, color='gray', ls='--', alpha=0.6)

    if fermi_level is not None:
        y0 = 0.0 if shift_fermi else fermi_level
        plt.axhline(y0, color='r', ls='--', lw=1.2, label=f'Fermi = {fermi_level:.2f} eV')

    plt.xticks(tick_positions, tick_labels)
    plt.xlabel('K-point Path')
    
    ylabel = 'E - E_F (eV)' if (shift_fermi and fermi_level is not None) else 'Energy (eV)'
    plt.ylabel(ylabel)
    if y_range:
        plt.ylim(y_range)
    plt.title(title)
    plt.grid(True, ls='--', alpha=0.4)
    if fermi_level is not None:
        plt.legend()
    plt.tight_layout()
    if savefig:
        if not os.path.exists(save_dir):
            os.makedirs(save_dir)
        out = os.path.join(save_dir, os.path.basename(savefig))
        plt.savefig(out, dpi=dpi or plt.rcParams['figure.dpi'])
        print(f"Saved figure to {out}")

    plt.show()

def plot_dos(dos_file, fermi_level=None, shift_fermi=False, y_range=None, x_range=None, dpi=None,
        save_dir="saved", savefig=None, vertical=False):
    """
    Plot the total Density of States (DOS) from a QE DOS file.

    Parameters
    ----------
    dos_file : str
        Path to the DOS file (columns: energy [eV], total DOS).
    fermi_level : float, optional
        Value of the Fermi energy (in eV). If provided, can be used to shift the plot.
    shift_fermi : bool, optional
        If True, shifts all energies so that the Fermi level appears at 0 eV.
    y_range : tuple or list, optional
        (ymin, ymax) limits for the DOS axis.
    dpi : int, optional
        Output resolution (dots per inch) for the plot.
    save_dir : str, optional
        Directory where the plot should be saved. Default is "saved".
    savefig : str, optional
        Filename for saving the figure. If None, the plot is only displayed.

    Returns
    -------
    None. Displays (and optionally saves) the DOS plot.
    """
    try:
        data = np.loadtxt(dos_file, comments='#')
    except Exception as e:
        # Fallback: sometimes QE files have a header line that loadtxt might miss if not starting with #
        # Try to read skipping the first row if it fails
        try:
             data = np.loadtxt(dos_file, skiprows=1)
        except Exception:
             raise ValueError(f"Could not read DOS file {dos_file}. Check format. Error: {e}")

    if data.ndim != 2 or data.shape[1] < 2:
        raise ValueError(f"Unexpected DOS file format: {dos_file}")
    E = data[:, 0]
    DOS = data[:, 1]
    if shift_fermi and fermi_level is not None:
        E = E - fermi_level
    if dpi is not None:
        plt.figure(figsize=(6,6), dpi=dpi)
    else:
        plt.figure(figsize=(6,6))

    if vertical:
        # DOS on X, Energy on Y
        plt.plot(DOS, E, 'k-', lw=1, label='Total DOS')
        if fermi_level is not None:
            y0 = 0.0 if shift_fermi else fermi_level
            plt.axhline(y0, color='r', ls='--', lw=1.2, label=f'Fermi = {fermi_level:.2f} eV')
        
        ylabel = 'E - E_F (eV)' if (shift_fermi and fermi_level is not None) else 'Energy (eV)'
        plt.ylabel(ylabel)
        plt.xlabel('DOS')
        if y_range:
            plt.ylim(y_range)
        if x_range:
            plt.xlim(x_range)
    else:
        # Energy on X, DOS on Y
        plt.plot(E, DOS, 'k-', lw=1, label='Total DOS')
        if fermi_level is not None:
            x0 = 0.0 if shift_fermi else fermi_level
            plt.axvline(x0, color='r', ls='--', lw=1.2, label=f'Fermi = {fermi_level:.2f} eV')
        
        xlabel = 'E - E_F (eV)' if (shift_fermi and fermi_level is not None) else 'Energy (eV)'
        plt.xlabel(xlabel)
        plt.ylabel('DOS')
        if y_range:
            plt.ylim(y_range)
        if x_range:
            plt.xlim(x_range)
    plt.title('Total DOS')
    plt.grid(True, ls='--', alpha=0.4)
    if fermi_level is not None:
        plt.legend()
    plt.tight_layout()
    if savefig:
        if not os.path.exists(save_dir):
            os.makedirs(save_dir)
        out = os.path.join(save_dir, os.path.basename(savefig))
        plt.savefig(out, dpi=dpi or plt.rcParams['figure.dpi'])
        print(f"Saved figure to {out}")

    plt.show()

def plot_pdos_dir(pdos_dir, fermi_level=None,
                  shift_fermi=False, y_range=None, dpi=None,pdos_mode='atomic',
                  save_dir="saved", savefig=None):
    """
    Plot projected Density of States (PDOS) from a set of QE projwfc/pdos files.

    Parameters
    ----------
    pdos_dir : str
        Directory containing PDOS files (one for each atom/orbital).
    fermi_level : float, optional
        Fermi energy (in eV). If given, can be used to shift the plot.
    shift_fermi : bool, optional
        If True, shifts all energies so the Fermi level is at 0 eV.
    y_range : tuple or list, optional
        (ymin, ymax) limits for the PDOS axis.
    dpi : int, optional
        Output resolution (dots per inch) for the plot.
    pdos_mode : str, optional
        How to group and sum PDOS channels on the plot:
          - 'atomic': sum all orbitals for each atom type (e.g., all Mo, S, W)
          - 'orbital': sum all atoms for each orbital (e.g., all p, d)
          - 'element_orbital': show each atom-orbital pair separately (e.g., Mo-d, S-p)
    save_dir : str, optional
        Directory to save the plot. Default is "saved".
    savefig : str, optional
        Filename for saving the figure. If None, the plot is only displayed.

    Returns
    -------
    None. Displays (and optionally saves) the PDOS plot.
    """
    pat = re.compile(r'atm#\d+\(([A-Za-z]+)\)_wfc#\d+\(([spdfgpxyz]+)(?:_j[0-9.]+)?\)') # Updated regex to catch _j for SOC files if present in filename
    fallback_pat = re.compile(r'atm#\d+\(([A-Za-z]+)\)_wfc#\d+\(([spdfgpxyz]+)\)')

    files = glob.glob(os.path.join(pdos_dir, '*pdos*'))
    if not files:
        raise FileNotFoundError(f"No PDOS files found in {pdos_dir}")
    grouped = {}
    E = None
    for fn in files:
        base = os.path.basename(fn)
        m = pat.search(base)
        if not m:
            m = fallback_pat.search(base)
        
        if not m:
            continue
            
        elem, orb = m.group(1), m.group(2)
        
        if pdos_mode == 'atomic':
            key = elem
        elif pdos_mode == 'orbital':
            key = orb
        elif pdos_mode == 'element_orbital':
            key = f"{elem}-{orb}"
        else:
            raise ValueError(f"Unknown pdos_mode: {pdos_mode}")
            
        data = np.loadtxt(fn, comments='#')
        if data.ndim != 2 or data.shape[1] < 2:
            continue
            
        # Check consistency: Col 0 should be Energy (not integer!)
        # Heuristic: if energies are all integers 0, 1, 2... it's likely a fatband file (k-index)
        if np.all(data[:,0] == np.arange(data.shape[0])):
             print(f"Warning: File {base} looks like a fatband file (Col 0 is index), but we expect Energy. Skipping to avoid bad plot.")
             continue

        if E is None:
            E = data[:, 0].copy()
            if shift_fermi and fermi_level is not None:
                E = E - fermi_level
                
        # Handle SOC or multiple columns
        # Standard QE PDOS: Col 1 = LDOS, Col 2... = m-resolved projections
        # We usually want the LDOS column if available, or sum of projections.
        if data.shape[1] >= 2:
            # If Col 1 is LDOS (usually is), take it.
            # If there are many columns (SOC has up, down, etc), usually Col 1 is still total for that projector?
            # Actually for SOC: columns are "upup", "downdown", "updown_real", "updown_imag" etc in some versions?
            # Or standard projwfc: Col 1 = LDOS, Col 2.. = projections.
            # Let's sum from column 1 onwards creates the total weight for this projector file
            # Wait, usually Col 1 is LDOS which IS the sum.
            # Let's define pd as column 1 (LDOS)
             pd = data[:, 1]
        else:
             pd = data[:, -1] # Fallback
             
        grouped.setdefault(key, np.zeros_like(pd))
        grouped[key] += pd
        
    if not grouped:
        raise RuntimeError("No PDOS channels matched; check filenames and pdos_mode")
    if dpi is not None:
        plt.figure(figsize=(6,6), dpi=dpi)
    else:
        plt.figure(figsize=(6,6))
    for k, pd in sorted(grouped.items()):
        plt.plot(E, pd, lw=1, label=k)
    if fermi_level is not None:
        x0 = 0.0 if shift_fermi else fermi_level
        plt.axvline(x0, color='r', ls='--', lw=1.2, label=f'Fermi = {fermi_level:.2f} eV')
    if fermi_level is not None:
        x0 = 0.0 if shift_fermi else fermi_level
        plt.axvline(x0, color='r', ls='--', lw=1.2, label=f'Fermi = {fermi_level:.2f} eV')
    
    xlabel = 'E - E_F (eV)' if (shift_fermi and fermi_level is not None) else 'Energy (eV)'
    plt.xlabel(xlabel)

    plt.ylabel('Projected DOS')
    if y_range:
        plt.ylim(y_range)
    plt.title(f'Projected DOS ({pdos_mode})')
    plt.grid(True, ls='--', alpha=0.4)
    plt.legend(fontsize='small', ncol=2)
    plt.tight_layout()
    if savefig:
        if not os.path.exists(save_dir):
            os.makedirs(save_dir)
        out = os.path.join(save_dir, os.path.basename(savefig))
        plt.savefig(out, dpi=dpi or plt.rcParams['figure.dpi'])
        print(f"Saved figure to {out}")

    plt.show()

def plot_fatbands(
    fatband_dir,
    kpath_file,
    band_file,
    mode='most',
    highlight_channel=None,
    dual=False,
    fermi_level=None,
    shift_fermi=False,
    y_range=None,
    cmap_name='tab10',
    s_min=10,
    s_max=100,
    weight_threshold=0.01,
    plot_total_dos=False,
    dos_file=None,
    overlay_bands_in_heat=False,
    heat_vmin=None,
    heat_vmax=None,
    dpi=None,
    layer_assignment=None ,
        save_dir="saved",
        savefig=None,
        spin=False,
        sub_orb=False
):
    """
      Plot fatbands from Quantum ESPRESSO data.

      This function visualizes band structures with atomic/orbital-resolved "fatbands"
      from QE projwfc files, supporting several visualization modes.


    Parameters
    ----------
    fatband_dir : str
        Directory containing fatband (PDOS/projwfc) files produced by Quantum ESPRESSO.
    kpath_file : str
        Path to the QE K_POINTS file in "crystal_b" format (defines k-point path and high-symmetry labels).
    band_file : str
        Path to the QE band structure file (usually ends with .bands.dat.gnu).
    mode : str, optional
        Visualization mode for fatbands. Controls how channel-resolved information is displayed:
          - 'most', 'atomic', 'orbital', 'element_orbital': Bubble modes (dominant channel per (k,E) as colored bubbles)
          - 'normal', 'o_atomic', 'o_orbital', 'o_element_orbital': Line modes (band color encodes channel fraction)
          - 'heat_total', 'heat_atomic', 'heat_orbital', 'heat_element_orbital': Heatmap modes (background color = channel weight)
          - 'layer': Color bands by layer (requires `layer_assignment`).
    highlight_channel : str or list, optional
        Channel(s) to highlight in line/heatmap modes.
          - For 'o_atomic': atom label (e.g., 'Mo', 'W', 'S').
          - For 'o_orbital': orbital label (e.g., 's', 'p', 'd').
          - For 'o_element_orbital': combined label (e.g., 'Mo-d', 'S-p').
          - For dual mode: list/tuple with two channels (e.g., ['Mo', 'S'] or ['d', 'p']).
        Not used in bubble modes.
    dual : bool, optional
        If True (with a list of two highlight channels), uses a colorbar to interpolate between the two channels along each band.
        Only for line modes ('o_atomic', etc.). Useful for visualizing smooth mixing between channels.
    fermi_level : float, optional
        Value of the Fermi energy (in eV). If set, can be used to shift the band/DOS plots such that the Fermi level is at zero.
    shift_fermi : bool, optional
        If True, shifts all band energies and DOS so that the Fermi level appears at 0 eV on the plot.
    y_range : tuple or list, optional
        (ymin, ymax) values for the energy axis (eV). Limits the displayed vertical range of the plot.
    cmap_name : str, optional
        Name of the matplotlib colormap to use for coloring channels/bands (default: 'tab10').
    s_min : float, optional
        Minimum marker size for bubbles or heatmap points (default: 10).
    s_max : float, optional
        Maximum marker size for bubbles or heatmap points (default: 100).
    weight_threshold : float, optional
        Fraction (0–1) of the global max channel weight to be plotted. Points with lower weight are omitted for clarity.
    plot_total_dos : bool, optional
        If True, plots the total DOS (from `dos_file`) alongside the fatbands.
    dos_file : str, optional
        Path to the total DOS file (energy, DOS columns), required if `plot_total_dos=True`.
    overlay_bands_in_heat : bool, optional
        If True, overlays plain band structure lines on top of heatmap plots for visual reference.
    heat_vmin : float, optional
        Minimum value for heatmap color normalization (default: data minimum).
    heat_vmax : float, optional
        Maximum value for heatmap color normalization (default: data maximum).
    dpi : int, optional
        Output resolution (dots per inch) for the plot figure.
    layer_assignment : dict, optional
        Only for 'layer' mode. Dictionary mapping atom names (e.g., 'Mo1', 'S3') to 'top' or 'bottom' layer.
    save_dir : str, optional
        Directory to save the plot. Default "saved".
    savefig : str, optional
        Filename for saving the generated plot (in a 'saved' directory within your project).
        If not set, the plot is only displayed and not saved.




      Returns
      -------
      None. Plots and saves the figure.

      ----"""


    # --- BUBBLE MODES ---
    # If mode in {'most', 'atomic', 'orbital', 'element_orbital'}:
    #   For each (k, E), show a colored bubble indicating which channel (atom/orbital/element-orbital) is dominant.
    #   Bubble size reflects the absolute weight. Each color = one channel.
    #   Use this to see "where" each atom or orbital dominates in the band structure.

    # --- LINE MODES ---
    # If mode in {'normal', 'o_atomic', 'o_orbital', 'o_element_orbital'}, or dual=True:
    #   Color the band lines themselves, using a colorbar to represent the fraction
    #   of one or two selected channels (e.g., d vs p orbitals, S vs Mo, etc.).
    #   Great for highlighting hybridization and channel mixing.

    # --- HEAT MODES ---
    # If mode in {'heat_total', 'heat_atomic', 'heat_orbital', 'heat_element_orbital'}:
    #   Plot a heatmap-style background showing absolute weights of total or selected channels.
    #   Band lines are overlaid for reference.

    # --- LAYER MODE ---
    # If mode == 'layer':
    #   For multilayer systems, color the bands by the relative contribution of "top" and "bottom" layers.
    #   The layer_assignment dictionary (atom: "top"/"bottom") is required.


    # Example usage comments for developers:
    #
    #   mode='o_atomic', highlight_channel='Mo'      # Color band lines by Mo atom fraction
    #   mode='o_orbital', highlight_channel='d'      # Color by d orbital contribution
    #   mode='o_element_orbital', highlight_channel='Mo-d' # Color by Mo-d orbital
    #   mode='o_atomic', highlight_channel=['Mo', 'S'], dual=True    # Color scale from Mo to S atoms
    #   mode='o_orbital', highlight_channel=['d', 'p'], dual=True    # Color scale from d to p orbitals
    #   mode='heat_atomic', highlight_channel='S'    # Heatmap of S atom weight
    #
    # Notes:
    #   - 'highlight_channel' must match a valid atom/orbital/element-orbital present in your system.
    #   - For dual coloring, highlight_channel should be a list/tuple of length 2.
    #   - Bubble modes ('atomic', etc.) ignore highlight_channel and color by dominant channel at each point.
    #   - 'layer' mode uses the 'layer_assignment' dict instead.

    labels, uniq_ik, E_grid, W_grids = read_fatband_files(fatband_dir,spin,sub_orb)
    N_k, N_e = E_grid.shape
    if shift_fermi and fermi_level is not None:
        E_grid = E_grid - fermi_level
    x_dist, band_energies, tick_positions, tick_labels, seg_ranges = read_band_xdistances(band_file, kpath_file)
    if len(x_dist) != N_k:
        print(f"Warning: fatband N_k={N_k} vs band file x_dist length={len(x_dist)}. They should match.")
    if plot_total_dos:
        if dos_file is None:
            raise ValueError("dos_file must be provided when plot_total_dos=True")
        dos_data = np.loadtxt(dos_file)
        if dos_data.ndim != 2 or dos_data.shape[1] < 2:
            raise ValueError(f"Unexpected DOS file format: {dos_file}")
        E_dos = dos_data[:,0]
        DOS   = dos_data[:,1]
        if shift_fermi and fermi_level is not None:
            E_dos = E_dos - fermi_level
    if mode == 'layer':
        atom_name_fn = lambda x: x
    else:
        atom_name_fn = strip_number

    elems = [atom_name_fn(a) for (a, _) in labels]
    orbs = [o for (_, o) in labels]
    ch_labels = [f"{atom_name_fn(a)}-{o}" for (a, o) in labels]
    bubble_modes = {'most','atomic','orbital','element_orbital'}
    line_modes = {'normal','o_atomic','o_orbital','o_element_orbital'}
    heat_modes = {'heat_total','heat_atomic','heat_orbital','heat_element_orbital'}


    if mode in bubble_modes:
        # Build grouped weights Wg
        if mode == 'atomic':
            unique_keys = sorted(set(elems))
            Wg = np.zeros((len(unique_keys), N_k, N_e))
            for i, key in enumerate(unique_keys):
                for idx, a in enumerate(elems):
                    if a == key:
                        Wg[i] += W_grids[idx]
        elif mode == 'orbital':
            unique_keys = sorted(set(orbs))
            Wg = np.zeros((len(unique_keys), N_k, N_e))
            for i, key in enumerate(unique_keys):
                for idx, o in enumerate(orbs):
                    if o == key:
                        Wg[i] += W_grids[idx]
        elif mode == 'element_orbital':
            unique_keys = sorted(set(ch_labels))
            Wg = np.zeros((len(unique_keys), N_k, N_e))
            for i, key in enumerate(unique_keys):
                for idx, lab in enumerate(ch_labels):
                    if lab == key:
                        Wg[i] += W_grids[idx]
        else:  # 'most'
            unique_keys = sorted(set(ch_labels))
            Wg = np.zeros((len(unique_keys), N_k, N_e))
            for i, key in enumerate(unique_keys):
                for idx, lab in enumerate(ch_labels):
                    if lab == key:
                        Wg[i] += W_grids[idx]
        # Determine dominant channel and weight
        idx_max = np.argmax(Wg, axis=0)  # shape (N_k, N_e)
        val_max = np.max(Wg, axis=0)
        # Flatten
        X_flat = np.repeat(x_dist, N_e)
        E_flat = E_grid.flatten()
        idx_flat = idx_max.flatten()
        val_flat = val_max.flatten()
        # Threshold
        global_max = np.nanmax(val_flat)
        thr = weight_threshold * global_max
        mask = val_flat > thr
        X_plot = X_flat[mask]
        E_plot = E_flat[mask]
        idx_plot = idx_flat[mask]
        val_plot = val_flat[mask]
        # Colors/sizes
        cmap = cm.get_cmap(cmap_name, len(unique_keys))
        colors = [cmap(i) for i in idx_plot]
        sizes = s_min + (s_max - s_min) * (val_plot / global_max if global_max>0 else 0)
        # Setup figure
        if plot_total_dos:
            if dpi is not None:
                fig, (ax1, ax2) = plt.subplots(1,2, gridspec_kw={'width_ratios':[3,1]}, figsize=(10,6), dpi=dpi, sharey=True)
            else:
                fig, (ax1, ax2) = plt.subplots(1,2, gridspec_kw={'width_ratios':[3,1]}, figsize=(10,6), sharey=True)
        else:
            if dpi is not None:
                fig, ax1 = plt.subplots(1,1,figsize=(8,6), dpi=dpi)
            else:
                fig, ax1 = plt.subplots(1,1,figsize=(8,6))
            ax2 = None
        # Scatter
        ax1.scatter(X_plot, E_plot, s=sizes, c=colors, edgecolor='k', lw=0.3, alpha=0.8, zorder=1)
        # Overlay band lines (split segments)
        for band in band_energies:
            for (s,e) in seg_ranges:
                if e > s:
                    y = band[s:e+1]
                    x = x_dist[s:e+1]
                    if shift_fermi and fermi_level is not None:
                        y = y - fermi_level
                    ax1.plot(x, y, color='gray', lw=0.5, zorder=0)
                else:
                    x = x_dist[s:s+1]
                    y = band[s:s+1]
                    if shift_fermi and fermi_level is not None:
                        y = y - fermi_level
                    ax1.plot(x, y, 'o', color='gray', markersize=2, zorder=0)
        ax1.set_xticks(tick_positions)
        ax1.set_xticklabels(tick_labels)
        ax1.set_xlabel('K-point Path')
        ax1.set_ylabel('Energy (eV)')
        if y_range:
            ax1.set_ylim(y_range)
        title_mode = mode.capitalize() if mode!='most' else 'Most'
        ax1.set_title(f'Fatbands ({title_mode})')
        # Legend
        for i, key in enumerate(unique_keys):
            ax1.scatter([], [], c=[cmap(i)], label=key, edgecolor='k', lw=0.3)
        ax1.legend(fontsize='small', ncol=2, loc='best')
        ax1.grid(True, ls='--', alpha=0.3)
        # Total DOS panel
        if plot_total_dos:
            ax2.plot(DOS, E_dos, 'k-', lw=1)
            ax2.set_xlabel('DOS')
            if y_range:
                ax2.set_ylim(y_range)
            ax2.axvline(0, color='gray', ls='--', lw=0.8)
            ax2.grid(True, ls='--', alpha=0.3)
        plt.tight_layout()
        if savefig:
            SAVE_DIR = os.path.join(SCRIPT_DIR, "saved")
            os.makedirs(SAVE_DIR, exist_ok=True)
            out = os.path.join(SAVE_DIR, os.path.basename(savefig))
            plt.savefig(out, dpi=dpi or plt.rcParams['figure.dpi'])
            print(f"Saved figure to {out}")

        plt.show()


    elif mode in line_modes or mode == 'layer':

        if mode == 'layer':

            atom_name_fn = lambda x: x

        else:

            atom_name_fn = strip_number

        elems = [a for (a, _) in labels]  # 'W1', 'S2', ...
        orbs = [o for (_, o) in labels]
        ch_labels = [f"{a}-{o}" for (a, o) in labels]

        

        if mode == 'layer':
            # 1. Unique atom names from labels (now like 'W1', 'Mo2', 'S3' ...)
            atom_names = sorted(set(a for (a, _) in labels))

            # 2. Use provided assignment, raise if not provided or incomplete
            if layer_assignment is None:
                raise ValueError("You must provide layer_assignment as a dict when using mode='layer'.")

            # 3. Validate all atoms are in assignment
            for atom in atom_names:
                if atom not in layer_assignment:
                    raise ValueError(f"layer_assignment is missing entry for atom '{atom}'. "
                                     f"Please supply all atoms: {atom_names}")

            # 4. Sum weights by layer
            W_top = np.zeros((N_k, N_e))
            W_bottom = np.zeros((N_k, N_e))
            for i, (a, o) in enumerate(labels):
                if layer_assignment[a] == 'top':
                    W_top += W_grids[i]
                elif layer_assignment[a] == 'bottom':
                    W_bottom += W_grids[i]
                else:
                    raise ValueError(
                        f"layer_assignment for atom '{a}' must be 'top' or 'bottom', not '{layer_assignment[a]}'.")

            W_sum = W_top + W_bottom
            W_sum[W_sum <= 0] = np.nan
            frac = W_top / W_sum  # 1 = all top, 0 = all bottom
            colorbar_label = 'Fraction of Top Layer (0=Bottom, 1=Top)'

        elif mode in line_modes:

            if dual:

                if isinstance(highlight_channel, str):

                    groups = [g.strip() for g in highlight_channel.split(',')]

                elif isinstance(highlight_channel, (list, tuple)):

                    groups = list(highlight_channel)

                else:

                    raise ValueError(

                        "For dual=True, highlight_channel must be 'g1,g2' or a two-element list/tuple"

                    )

                if len(groups) != 2:
                    raise ValueError(f"dual mode needs exactly two groups, got {groups!r}")

                key1, key2 = groups

                if mode == 'o_atomic':

                    valid = sorted(set([a for (a, _) in labels]))



                elif mode == 'o_orbital':

                    valid = sorted(set(orbs))

                else:

                    valid = sorted(set(ch_labels))

                if key1 not in valid or key2 not in valid:
                    raise ValueError(f"dual keys {groups!r} must be among {valid}")

                W1 = np.zeros((N_k, N_e))

                W2 = np.zeros((N_k, N_e))

                if mode == 'o_atomic':
                    for i, (a, _) in enumerate(labels):
                        if a == key1:
                            W1 += W_grids[i]
                        elif a == key2:
                            W2 += W_grids[i]

                elif mode == 'o_orbital':

                    for i, o in enumerate(orbs):

                        if o == key1:
                            W1 += W_grids[i]

                        elif o == key2:
                            W2 += W_grids[i]

                else:

                    for i, lab in enumerate(ch_labels):

                        if lab == key1:
                            W1 += W_grids[i]

                        elif lab == key2:
                            W2 += W_grids[i]

                W12 = W1 + W2

                W12_safe = W12.copy()

                W12_safe[W12_safe <= 0] = np.nan

                frac = W2 / W12_safe

                colorbar_label = f'Fraction of {key2}   (0={key1}, 1={key2})'

            else:

                if mode == 'o_atomic':

                    if highlight_channel is None:
                        raise ValueError("highlight_channel must be provided for o_atomic mode")

                    unique_atoms = sorted(set(elems))

                    if highlight_channel not in unique_atoms:
                        raise ValueError(f"highlight_channel '{highlight_channel}' not in atomic keys {unique_atoms}")

                    Wtot = np.zeros((N_k, N_e));
                    Whigh = np.zeros((N_k, N_e))

                    for idx, a in enumerate(elems):

                        Wtot += W_grids[idx]

                        if a == highlight_channel:
                            Whigh += W_grids[idx]

                elif mode == 'o_orbital':

                    if highlight_channel is None:
                        raise ValueError("highlight_channel must be provided for o_orbital mode")

                    unique_orbs = sorted(set(orbs))

                    if highlight_channel not in unique_orbs:
                        raise ValueError(f"highlight_channel '{highlight_channel}' not in orbital keys {unique_orbs}")

                    Wtot = np.zeros((N_k, N_e));
                    Whigh = np.zeros((N_k, N_e))

                    for idx, o in enumerate(orbs):

                        Wtot += W_grids[idx]

                        if o == highlight_channel:
                            Whigh += W_grids[idx]

                elif mode == 'o_element_orbital':

                    if highlight_channel is None:
                        raise ValueError("highlight_channel must be provided for o_element_orbital mode")

                    unique_eo = sorted(set(ch_labels))

                    if highlight_channel not in unique_eo:
                        raise ValueError(
                            f"highlight_channel '{highlight_channel}' not in element-orbital keys {unique_eo}")

                    Wtot = np.zeros((N_k, N_e));
                    Whigh = np.zeros((N_k, N_e))

                    for idx, lab in enumerate(ch_labels):

                        Wtot += W_grids[idx]

                        if lab == highlight_channel:
                            Whigh += W_grids[idx]

                else:  # normal

                    Wtot = np.ones((N_k, N_e))

                    Whigh = np.zeros((N_k, N_e))

                Wtot_safe = Wtot.copy()

                Wtot_safe[Wtot_safe <= 0] = np.nan

                frac = Whigh / Wtot_safe

                colorbar_label = f'Fraction of {highlight_channel}'

        # ------ PLOTTING PART (shared for all line/layer modes) ------

        cmap = plt.get_cmap(cmap_name)

        norm = plt.Normalize(0.0, 1.0)

        nbands = band_energies.shape[0]

        if plot_total_dos:

            if dpi is not None:

                fig, (ax1, ax2) = plt.subplots(1, 2, gridspec_kw={'width_ratios': [3, 1]},

                                               figsize=(10, 6), dpi=dpi, sharey=True)

            else:

                fig, (ax1, ax2) = plt.subplots(1, 2, gridspec_kw={'width_ratios': [3, 1]},

                                               figsize=(10, 6), sharey=True)

        else:

            if dpi is not None:

                fig, ax1 = plt.subplots(1, 1, figsize=(8, 6), dpi=dpi)

            else:

                fig, ax1 = plt.subplots(1, 1, figsize=(8, 6))

            ax2 = None

        for b in range(nbands):

            y_line = band_energies[b].copy()

            if shift_fermi and fermi_level is not None:
                y_line = y_line - fermi_level

            x_line = x_dist

            for (s, e) in seg_ranges:

                if e <= s:
                    continue

                xs = x_line[s:e + 1];
                ys = y_line[s:e + 1]

                points = np.array([xs, ys]).T.reshape(-1, 1, 2)

                segments = np.concatenate([points[:-1], points[1:]], axis=1)

                frac_vals = []

                for i_k in range(s, e + 1):

                    Eb = band_energies[b, i_k]

                    Eb0 = Eb - fermi_level if (shift_fermi and fermi_level is not None) else Eb

                    row = E_grid[i_k, :]

                    j = np.argmin(np.abs(row - Eb0))

                    fv = frac[i_k, j]

                    if np.isnan(fv): fv = 0.0

                    frac_vals.append(fv)

                frac_seg = 0.5 * (np.array(frac_vals[:-1]) + np.array(frac_vals[1:]))

                lc = mcoll.LineCollection(segments, array=frac_seg, cmap=cmap,

                                          norm=norm, linewidth=2, zorder=1)

                ax1.add_collection(lc)

        ax1.set_xticks(tick_positions)

        ax1.set_xticklabels(tick_labels)

        ax1.set_xlabel('K-point Path')

        ax1.set_ylabel('Energy (eV)')

        if y_range:
            ax1.set_ylim(y_range)

        if mode == 'layer':

            ax1.set_title('Fatbands (Layer)')

        else:

            title_mode = mode if mode != 'normal' else f"Highlight {highlight_channel}"

            ax1.set_title(f'Fatbands ({title_mode})')

        sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)

        sm.set_array([])

        cbar = plt.colorbar(sm, ax=ax1, pad=0.02)

        cbar.set_label(colorbar_label)

        if overlay_bands_in_heat:

            for band in band_energies:

                for (s, e) in seg_ranges:

                    if e > s:

                        y = band[s:e + 1];
                        x = x_dist[s:e + 1]

                        if shift_fermi and fermi_level is not None:
                            y = y - fermi_level

                        ax1.plot(x, y, color='lightgray', lw=0.5, zorder=0)

                    else:

                        x = x_dist[s];
                        y = band[s]

                        if shift_fermi and fermi_level is not None:
                            y = y - fermi_level

                        ax1.plot(x, y, color='lightgray', lw=0.5, zorder=0)

        ax1.grid(True, ls='--', alpha=0.3)



        # Total DOS panel for line/layer modes
        if plot_total_dos:
            if shift_fermi and fermi_level is not None:
                E_dos_plot = E_dos
            else:
                E_dos_plot = E_dos
            ax2.plot(DOS, E_dos_plot, 'k-', lw=1)
            ax2.set_xlabel('DOS')
            if y_range:
                ax2.set_ylim(y_range)
            ax2.axvline(0, color='gray', ls='--', lw=0.8)
            ax2.grid(True, ls='--', alpha=0.3)

        plt.tight_layout()
        if savefig:
            if not os.path.exists(save_dir):
                os.makedirs(save_dir)
            out = os.path.join(save_dir, os.path.basename(savefig))
            plt.savefig(out, dpi=dpi or plt.rcParams['figure.dpi'])
            print(f"Saved figure to {out}")

        plt.show()


    elif mode in heat_modes:
        
    # ... (skipping unchanged lines) ...
    
        # Total DOS panel
        if plot_total_dos:
            if shift_fermi and fermi_level is not None:
                E_dos_plot = E_dos
            else:
                E_dos_plot = E_dos
            ax2.plot(DOS, E_dos_plot, 'k-', lw=1)
            ax2.set_xlabel('DOS')
            if y_range:
                ax2.set_ylim(y_range)
            ax2.axvline(0, color='gray', ls='--', lw=0.8)
            ax2.grid(True, ls='--', alpha=0.3)
        plt.tight_layout()
        if savefig:
            if not os.path.exists(save_dir):
                 os.makedirs(save_dir)
            out = os.path.join(save_dir, os.path.basename(savefig))
            plt.savefig(out, dpi=dpi or plt.rcParams['figure.dpi'])
            print(f"Saved figure to {out}")

        plt.show()


    elems = [atom_name_fn(a) for (a, _) in labels]
    orbs = [o for (_, o) in labels]
    ch_labels = [f"{atom_name_fn(a)}-{o}" for (a, o) in labels]
    bubble_modes = {'most','atomic','orbital','element_orbital'}
    line_modes = {'normal','o_atomic','o_orbital','o_element_orbital'}
    heat_modes = {'heat_total','heat_atomic','heat_orbital','heat_element_orbital'}


    if mode in bubble_modes:
        # Build grouped weights Wg
        if mode == 'atomic':
            unique_keys = sorted(set(elems))
            Wg = np.zeros((len(unique_keys), N_k, N_e))
            for i, key in enumerate(unique_keys):
                for idx, a in enumerate(elems):
                    if a == key:
                        Wg[i] += W_grids[idx]
        elif mode == 'orbital':
            unique_keys = sorted(set(orbs))
            Wg = np.zeros((len(unique_keys), N_k, N_e))
            for i, key in enumerate(unique_keys):
                for idx, o in enumerate(orbs):
                    if o == key:
                        Wg[i] += W_grids[idx]
        elif mode == 'element_orbital':
            unique_keys = sorted(set(ch_labels))
            Wg = np.zeros((len(unique_keys), N_k, N_e))
            for i, key in enumerate(unique_keys):
                for idx, lab in enumerate(ch_labels):
                    if lab == key:
                        Wg[i] += W_grids[idx]
        else:  # 'most'
            unique_keys = sorted(set(ch_labels))
            Wg = np.zeros((len(unique_keys), N_k, N_e))
            for i, key in enumerate(unique_keys):
                for idx, lab in enumerate(ch_labels):
                    if lab == key:
                        Wg[i] += W_grids[idx]
        # Determine dominant channel and weight
        idx_max = np.argmax(Wg, axis=0)  # shape (N_k, N_e)
        val_max = np.max(Wg, axis=0)
        # Flatten
        X_flat = np.repeat(x_dist, N_e)
        E_flat = E_grid.flatten()
        idx_flat = idx_max.flatten()
        val_flat = val_max.flatten()
        # Threshold
        global_max = np.nanmax(val_flat)
        thr = weight_threshold * global_max
        mask = val_flat > thr
        X_plot = X_flat[mask]
        E_plot = E_flat[mask]
        idx_plot = idx_flat[mask]
        val_plot = val_flat[mask]
        # Colors/sizes
        cmap = cm.get_cmap(cmap_name, len(unique_keys))
        colors = [cmap(i) for i in idx_plot]
        sizes = s_min + (s_max - s_min) * (val_plot / global_max if global_max>0 else 0)
        # Setup figure
        if plot_total_dos:
            if dpi is not None:
                fig, (ax1, ax2) = plt.subplots(1,2, gridspec_kw={'width_ratios':[3,1]}, figsize=(10,6), dpi=dpi, sharey=True)
            else:
                fig, (ax1, ax2) = plt.subplots(1,2, gridspec_kw={'width_ratios':[3,1]}, figsize=(10,6), sharey=True)
        else:
            if dpi is not None:
                fig, ax1 = plt.subplots(1,1,figsize=(8,6), dpi=dpi)
            else:
                fig, ax1 = plt.subplots(1,1,figsize=(8,6))
            ax2 = None
        # Scatter
        ax1.scatter(X_plot, E_plot, s=sizes, c=colors, edgecolor='k', lw=0.3, alpha=0.8, zorder=1)
        # Overlay band lines (split segments)
        for band in band_energies:
            for (s,e) in seg_ranges:
                if e > s:
                    y = band[s:e+1]
                    x = x_dist[s:e+1]
                    if shift_fermi and fermi_level is not None:
                        y = y - fermi_level
                    ax1.plot(x, y, color='gray', lw=0.5, zorder=0)
                else:
                    x = x_dist[s:s+1]
                    y = band[s:s+1]
                    if shift_fermi and fermi_level is not None:
                        y = y - fermi_level
                    ax1.plot(x, y, 'o', color='gray', markersize=2, zorder=0)
        ax1.set_xticks(tick_positions)
        ax1.set_xticklabels(tick_labels)
        ax1.set_xlabel('K-point Path')
        ax1.set_ylabel('Energy (eV)')
        if y_range:
            ax1.set_ylim(y_range)
        title_mode = mode.capitalize() if mode!='most' else 'Most'
        ax1.set_title(f'Fatbands ({title_mode})')
        # Legend
        for i, key in enumerate(unique_keys):
            ax1.scatter([], [], c=[cmap(i)], label=key, edgecolor='k', lw=0.3)
        ax1.legend(fontsize='small', ncol=2, loc='best')
        ax1.grid(True, ls='--', alpha=0.3)
        # Total DOS panel
        if plot_total_dos:
            ax2.plot(DOS, E_dos, 'k-', lw=1)
            ax2.set_xlabel('DOS')
            if y_range:
                ax2.set_ylim(y_range)
            ax2.axvline(0, color='gray', ls='--', lw=0.8)
            ax2.grid(True, ls='--', alpha=0.3)
        plt.tight_layout()
        if savefig:
            if not os.path.exists(save_dir):
                os.makedirs(save_dir)
            out = os.path.join(save_dir, os.path.basename(savefig))
            plt.savefig(out, dpi=dpi or plt.rcParams['figure.dpi'])
            print(f"Saved figure to {out}")

        plt.show()


    elif mode in line_modes or mode == 'layer':

        if mode == 'layer':

            atom_name_fn = lambda x: x

        else:

            atom_name_fn = strip_number

        elems = [a for (a, _) in labels]  # 'W1', 'S2', ...
        orbs = [o for (_, o) in labels]
        ch_labels = [f"{a}-{o}" for (a, o) in labels]

        

        if mode == 'layer':
            # 1. Unique atom names from labels (now like 'W1', 'Mo2', 'S3' ...)
            atom_names = sorted(set(a for (a, _) in labels))

            # 2. Use provided assignment, raise if not provided or incomplete
            if layer_assignment is None:
                raise ValueError("You must provide layer_assignment as a dict when using mode='layer'.")

            # 3. Validate all atoms are in assignment
            for atom in atom_names:
                if atom not in layer_assignment:
                    raise ValueError(f"layer_assignment is missing entry for atom '{atom}'. "
                                     f"Please supply all atoms: {atom_names}")

            # 4. Sum weights by layer
            W_top = np.zeros((N_k, N_e))
            W_bottom = np.zeros((N_k, N_e))
            for i, (a, o) in enumerate(labels):
                if layer_assignment[a] == 'top':
                    W_top += W_grids[i]
                elif layer_assignment[a] == 'bottom':
                    W_bottom += W_grids[i]
                else:
                    raise ValueError(
                        f"layer_assignment for atom '{a}' must be 'top' or 'bottom', not '{layer_assignment[a]}'.")

            W_sum = W_top + W_bottom
            W_sum[W_sum <= 0] = np.nan
            frac = W_top / W_sum  # 1 = all top, 0 = all bottom
            colorbar_label = 'Fraction of Top Layer (0=Bottom, 1=Top)'

        elif mode in line_modes:

            if dual:

                if isinstance(highlight_channel, str):

                    groups = [g.strip() for g in highlight_channel.split(',')]

                elif isinstance(highlight_channel, (list, tuple)):

                    groups = list(highlight_channel)

                else:

                    raise ValueError(

                        "For dual=True, highlight_channel must be 'g1,g2' or a two-element list/tuple"

                    )

                if len(groups) != 2:
                    raise ValueError(f"dual mode needs exactly two groups, got {groups!r}")

                key1, key2 = groups

                if mode == 'o_atomic':

                    valid = sorted(set([a for (a, _) in labels]))



                elif mode == 'o_orbital':

                    valid = sorted(set(orbs))

                else:

                    valid = sorted(set(ch_labels))

                if key1 not in valid or key2 not in valid:
                    raise ValueError(f"dual keys {groups!r} must be among {valid}")

                W1 = np.zeros((N_k, N_e))

                W2 = np.zeros((N_k, N_e))

                if mode == 'o_atomic':
                    for i, (a, _) in enumerate(labels):
                        if a == key1:
                            W1 += W_grids[i]
                        elif a == key2:
                            W2 += W_grids[i]

                elif mode == 'o_orbital':

                    for i, o in enumerate(orbs):

                        if o == key1:
                            W1 += W_grids[i]

                        elif o == key2:
                            W2 += W_grids[i]

                else:

                    for i, lab in enumerate(ch_labels):

                        if lab == key1:
                            W1 += W_grids[i]

                        elif lab == key2:
                            W2 += W_grids[i]

                W12 = W1 + W2

                W12_safe = W12.copy()

                W12_safe[W12_safe <= 0] = np.nan

                frac = W2 / W12_safe

                colorbar_label = f'Fraction of {key2}   (0={key1}, 1={key2})'

            else:

                if mode == 'o_atomic':

                    if highlight_channel is None:
                        raise ValueError("highlight_channel must be provided for o_atomic mode")

                    unique_atoms = sorted(set(elems))

                    if highlight_channel not in unique_atoms:
                        raise ValueError(f"highlight_channel '{highlight_channel}' not in atomic keys {unique_atoms}")

                    Wtot = np.zeros((N_k, N_e));
                    Whigh = np.zeros((N_k, N_e))

                    for idx, a in enumerate(elems):

                        Wtot += W_grids[idx]

                        if a == highlight_channel:
                            Whigh += W_grids[idx]

                elif mode == 'o_orbital':

                    if highlight_channel is None:
                        raise ValueError("highlight_channel must be provided for o_orbital mode")

                    unique_orbs = sorted(set(orbs))

                    if highlight_channel not in unique_orbs:
                        raise ValueError(f"highlight_channel '{highlight_channel}' not in orbital keys {unique_orbs}")

                    Wtot = np.zeros((N_k, N_e));
                    Whigh = np.zeros((N_k, N_e))

                    for idx, o in enumerate(orbs):

                        Wtot += W_grids[idx]

                        if o == highlight_channel:
                            Whigh += W_grids[idx]

                elif mode == 'o_element_orbital':

                    if highlight_channel is None:
                        raise ValueError("highlight_channel must be provided for o_element_orbital mode")

                    unique_eo = sorted(set(ch_labels))

                    if highlight_channel not in unique_eo:
                        raise ValueError(
                            f"highlight_channel '{highlight_channel}' not in element-orbital keys {unique_eo}")

                    Wtot = np.zeros((N_k, N_e));
                    Whigh = np.zeros((N_k, N_e))

                    for idx, lab in enumerate(ch_labels):

                        Wtot += W_grids[idx]

                        if lab == highlight_channel:
                            Whigh += W_grids[idx]

                else:  # normal

                    Wtot = np.ones((N_k, N_e))

                    Whigh = np.zeros((N_k, N_e))

                Wtot_safe = Wtot.copy()

                Wtot_safe[Wtot_safe <= 0] = np.nan

                frac = Whigh / Wtot_safe

                colorbar_label = f'Fraction of {highlight_channel}'

        # ------ PLOTTING PART (shared for all line/layer modes) ------

        cmap = plt.get_cmap(cmap_name)

        norm = plt.Normalize(0.0, 1.0)

        nbands = band_energies.shape[0]

        if plot_total_dos:

            if dpi is not None:

                fig, (ax1, ax2) = plt.subplots(1, 2, gridspec_kw={'width_ratios': [3, 1]},

                                               figsize=(10, 6), dpi=dpi, sharey=True)

            else:

                fig, (ax1, ax2) = plt.subplots(1, 2, gridspec_kw={'width_ratios': [3, 1]},

                                               figsize=(10, 6), sharey=True)

        else:

            if dpi is not None:

                fig, ax1 = plt.subplots(1, 1, figsize=(8, 6), dpi=dpi)

            else:

                fig, ax1 = plt.subplots(1, 1, figsize=(8, 6))

            ax2 = None

        for b in range(nbands):

            y_line = band_energies[b].copy()

            if shift_fermi and fermi_level is not None:
                y_line = y_line - fermi_level

            x_line = x_dist

            for (s, e) in seg_ranges:

                if e <= s:
                    continue

                xs = x_line[s:e + 1];
                ys = y_line[s:e + 1]

                points = np.array([xs, ys]).T.reshape(-1, 1, 2)

                segments = np.concatenate([points[:-1], points[1:]], axis=1)

                frac_vals = []

                for i_k in range(s, e + 1):

                    Eb = band_energies[b, i_k]

                    Eb0 = Eb - fermi_level if (shift_fermi and fermi_level is not None) else Eb

                    row = E_grid[i_k, :]

                    j = np.argmin(np.abs(row - Eb0))

                    fv = frac[i_k, j]

                    if np.isnan(fv): fv = 0.0

                    frac_vals.append(fv)

                frac_seg = 0.5 * (np.array(frac_vals[:-1]) + np.array(frac_vals[1:]))

                lc = mcoll.LineCollection(segments, array=frac_seg, cmap=cmap,

                                          norm=norm, linewidth=2, zorder=1)

                ax1.add_collection(lc)

        ax1.set_xticks(tick_positions)

        ax1.set_xticklabels(tick_labels)

        ax1.set_xlabel('K-point Path')
        
        ylabel = 'E - E_F (eV)' if (shift_fermi and fermi_level is not None) else 'Energy (eV)'
        ax1.set_ylabel(ylabel)

        if y_range:
            ax1.set_ylim(y_range)

        if mode == 'layer':

            ax1.set_title('Fatbands (Layer)')

        else:

            title_mode = mode if mode != 'normal' else f"Highlight {highlight_channel}"

            ax1.set_title(f'Fatbands ({title_mode})')

        sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)

        sm.set_array([])

        cbar = plt.colorbar(sm, ax=ax1, pad=0.02)

        cbar.set_label(colorbar_label)

        if overlay_bands_in_heat:

            for band in band_energies:

                for (s, e) in seg_ranges:

                    if e > s:

                        y = band[s:e + 1];
                        x = x_dist[s:e + 1]

                        if shift_fermi and fermi_level is not None:
                            y = y - fermi_level

                        ax1.plot(x, y, color='lightgray', lw=0.5, zorder=0)

                    else:

                        x = x_dist[s];
                        y = band[s]

                        if shift_fermi and fermi_level is not None:
                            y = y - fermi_level

                        ax1.plot(x, y, color='lightgray', lw=0.5, zorder=0)

        ax1.grid(True, ls='--', alpha=0.3)

        plt.tight_layout()
        if savefig:
            if not os.path.exists(save_dir):
                os.makedirs(save_dir)
            out = os.path.join(save_dir, os.path.basename(savefig))
            plt.savefig(out, dpi=dpi or plt.rcParams['figure.dpi'])
            print(f"Saved figure to {out}")

        plt.show()
    elif mode in heat_modes:
        # Heatmap modes: show intensity (weight) as colored background along bands
        # Modes: 'heat_total', 'heat_atomic', 'heat_orbital', 'heat_element_orbital'
        if mode == 'heat_total':
            # sum all channels
            Wtot = np.zeros((N_k, N_e))
            for arr in W_grids:
                Wtot += arr
            heat_grid = Wtot
            heat_label = 'Total weight'
        else:
            if highlight_channel is None:
                raise ValueError(f"highlight_channel must be provided for {mode}")
            if mode == 'heat_atomic':
                unique_atoms = sorted(set(elems))
                if highlight_channel not in unique_atoms:
                    raise ValueError(f"highlight_channel '{highlight_channel}' not in atomic keys {unique_atoms}")
                Whigh = np.zeros((N_k, N_e))
                for idx, a in enumerate(elems):
                    if a == highlight_channel:
                        Whigh += W_grids[idx]
                heat_grid = Whigh
                heat_label = f"Weight of atom {highlight_channel}"
            elif mode == 'heat_orbital':
                unique_orbs = sorted(set(orbs))
                if highlight_channel not in unique_orbs:
                    raise ValueError(f"highlight_channel '{highlight_channel}' not in orbital keys {unique_orbs}")
                Whigh = np.zeros((N_k, N_e))
                for idx, o in enumerate(orbs):
                    if o == highlight_channel:
                        Whigh += W_grids[idx]
                heat_grid = Whigh
                heat_label = f"Weight of orbital {highlight_channel}"
            elif mode == 'heat_element_orbital':
                unique_eo = sorted(set(ch_labels))
                if highlight_channel not in unique_eo:
                    raise ValueError(f"highlight_channel '{highlight_channel}' not in element-orbital keys {unique_eo}")
                Whigh = np.zeros((N_k, N_e))
                for idx, lab in enumerate(ch_labels):
                    if lab == highlight_channel:
                        Whigh += W_grids[idx]
                heat_grid = Whigh
                heat_label = f"Weight of {highlight_channel}"
            else:
                raise ValueError(f"Unknown heat mode: {mode}")
        # Setup figure
        if plot_total_dos:
            if dpi is not None:
                fig, (ax1, ax2) = plt.subplots(1,2, gridspec_kw={'width_ratios':[3,1]}, figsize=(10,6), dpi=dpi, sharey=True)
            else:
                fig, (ax1, ax2) = plt.subplots(1,2, gridspec_kw={'width_ratios':[3,1]}, figsize=(10,6), sharey=True)
        else:
            if dpi is not None:
                fig, ax1 = plt.subplots(1,1,figsize=(8,6), dpi=dpi)
            else:
                fig, ax1 = plt.subplots(1,1,figsize=(8,6))
            ax2 = None
        # Flatten grid
        X_flat = np.repeat(x_dist, N_e)
        E_flat = E_grid.flatten()
        W_flat = heat_grid.flatten()
        # Color normalization
        vmin = heat_vmin if heat_vmin is not None else np.nanmin(W_flat)
        vmax = heat_vmax if heat_vmax is not None else np.nanmax(W_flat)
        norm = plt.Normalize(vmin=vmin, vmax=vmax)
        cmap = plt.get_cmap(cmap_name)
        # Plot each point as small square marker
        mask = ~np.isnan(W_flat)
        Xp = X_flat[mask]
        Ep = E_flat[mask]
        Wp = W_flat[mask]
        colors = cmap(norm(Wp))
        s_heat = (s_min + s_max) / 2.0
        ax1.scatter(Xp, Ep, s=s_heat, c=colors, marker='s', edgecolor='none', alpha=1.0, zorder=0)
        # Optionally overlay band lines
        if overlay_bands_in_heat:
            for band in band_energies:
                for (s,e) in seg_ranges:
                    if e > s:
                        y = band[s:e+1]
                        x = x_dist[s:e+1]
                        if shift_fermi and fermi_level is not None:
                            y = y - fermi_level
                        ax1.plot(x, y, color='lightgray', lw=0.5, zorder=1)
                    else:
                        x = x_dist[s]
                        y = band[s]
                        if shift_fermi and fermi_level is not None:
                            y = y - fermi_level
                        ax1.plot(x, y, 'o', color='lightgray', markersize=2, zorder=1)
        # X-ticks
        ax1.set_xticks(tick_positions)
        ax1.set_xticklabels(tick_labels)
        ax1.set_xlabel('K-point Path')
        
        ylabel = 'E - E_F (eV)' if (shift_fermi and fermi_level is not None) else 'Energy (eV)'
        ax1.set_ylabel(ylabel)
        if y_range:
            ax1.set_ylim(y_range)
        # Title and colorbar
        mode_title = mode.replace('_',' ').title()
        ax1.set_title(f'Fatbands ({mode_title})')
        sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
        sm.set_array([])
        cbar = plt.colorbar(sm, ax=ax1, pad=0.02)
        cbar.set_label(heat_label)
        ax1.grid(True, ls='--', alpha=0.3)
        # Total DOS panel
        if plot_total_dos:
            if shift_fermi and fermi_level is not None:
                E_dos_plot = E_dos
            else:
                E_dos_plot = E_dos
            ax2.plot(DOS, E_dos_plot, 'k-', lw=1)
            ax2.set_xlabel('DOS')
            if y_range:
                ax2.set_ylim(y_range)
            ax2.axvline(0, color='gray', ls='--', lw=0.8)
            ax2.grid(True, ls='--', alpha=0.3)
        plt.tight_layout()
        if savefig:
            if not os.path.exists(save_dir):
                os.makedirs(save_dir)
            out = os.path.join(save_dir, os.path.basename(savefig))
            plt.savefig(out, dpi=dpi or plt.rcParams['figure.dpi'])
            print(f"Saved figure to {out}")

        plt.show()

    else:
        raise ValueError(f"Unknown fatbands mode: {mode}")

# ==============================
# MAIN ENTRYPOINT
# ==============================

def plot_from_file(
    plot_type='band',
    pdos_dir=None,
    fatband_dir=None,
    kpath_file=None,
    band_file=None,
    dos_file=None,
    pdos_mode='atomic',
    fatbands_mode='most',
    highlight_channel=None,
    dual=False,
    band_mode='normal',
    cmap_name='tab10',
    band_file2=None,  # EKLEDİK!
    kpath_file2=None,
        color1='red',
        color2='blue',
        label1='Band 1',
        label2='Band 2',
    s_min=10,
    s_max=100,
    weight_threshold=0.01,
    y_range=None,
    x_range=None,
    fermi_level=None,
    shift_fermi=False,
    plot_total_dos=False,
    overlay_bands_in_heat=False,
    heat_vmin=None,
    heat_vmax=None,
    dpi=None,
    layer_assignment=None,
        save_dir="saved",
        savefig=None,
        spin=False,
        sub_orb=False,
        vertical=False

):
    """
        High-level wrapper for plotting Quantum ESPRESSO band, DOS, PDOS, and fatbands in one function.

        This function lets you plot a band structure, total DOS, projected DOS (PDOS), or fatbands
        simply by specifying the plot type and relevant file paths.
        It automatically calls the correct plot function with all the necessary arguments.

        Parameters
        ----------
        plot_type : str, optional
            What kind of plot to produce. Must be one of:
                - 'band': electronic band structure
                - 'dos': total density of states
                - 'pdos': projected density of states
                - 'fatbands': fatband plot (atom/orbital-resolved bands)
        pdos_dir : str, optional
            Directory containing PDOS files (required for 'pdos' and optionally for 'fatbands').
        fatband_dir : str, optional
            Directory containing fatband/projwfc files (required for 'fatbands').
        kpath_file : str, optional
            Path to the K_POINTS (crystal_b) file for band structure plots.
        band_file : str, optional
            Path to the QE band structure file (.bands.dat.gnu).
        dos_file : str, optional
            Path to the total DOS file (columns: energy, DOS).
        pdos_mode : str, optional
            PDOS plot grouping mode ('atomic', 'orbital', or 'element_orbital').
        fatbands_mode : str, optional
            Fatband plot mode ('most', 'atomic', 'orbital', 'element_orbital', etc.).
        highlight_channel : str or list, optional
            Channel(s) to highlight for line or heatmap fatband modes.
        dual : bool, optional
            If True, compare two highlight channels in line fatband modes.
        band_mode : str, optional
            Band plot style (see plot_band docstring).
        cmap_name : str, optional
            Name of the matplotlib colormap.
        s_min, s_max : float, optional
            Min/max marker size for bubble/heatmap modes.
        weight_threshold : float, optional
            Threshold for displaying small weights (fatbands).
        y_range : tuple or list, optional
            (ymin, ymax) for energy axis.
        fermi_level : float, optional
            Fermi energy (eV). Used for shifting plots if desired.
        shift_fermi : bool, optional
            If True, shifts the Fermi level to 0 eV in plots.
        plot_total_dos : bool, optional
            If True, plots total DOS alongside fatbands.
        overlay_bands_in_heat : bool, optional
            If True, overlays band lines on heatmap fatbands.
        heat_vmin, heat_vmax : float, optional
            Min/max for heatmap normalization.
        dpi : int, optional
            Output resolution for the plot.
        layer_assignment : dict, optional
            For 'layer' fatband mode, maps atoms to 'top'/'bottom' layers.
        save_dir : str, optional
            Directory where the plot should be saved. Default is "saved".
        savefig : str, optional
            Filename for saving the plot (inside the 'saved' folder). If None, plot is only displayed.

        Returns
        -------
        None. Calls the appropriate plot function, which shows and/or saves the plot.

        Examples
        --------
        # Plot band structure:
        plot_from_file(plot_type='band', band_file='bands.dat.gnu', kpath_file='kpath.in')

        # Plot total DOS:
        plot_from_file(plot_type='dos', dos_file='dos.dat')

        # Plot atom-projected PDOS:
        plot_from_file(plot_type='pdos', pdos_dir='pdos/', pdos_mode='atomic')

        # Plot fatbands by atomic species:
        plot_from_file(
            plot_type='fatbands',
            band_file='bands.dat.gnu',
            fatband_dir='fatbands/',
            kpath_file='kpath.in',
            fatbands_mode='atomic',
            savefig='fatbands_by_atom.pdf'
        )
        """







    pt = plot_type.lower()
    if pt == 'band':
        plot_band(
            band_file=band_file,
            kpath_file=kpath_file,
            fermi_level=fermi_level,
            shift_fermi=shift_fermi,
            y_range=y_range,
            dpi=dpi,
            band_mode=band_mode,
            fatband_dir=fatband_dir,
            cmap_name=cmap_name,
            save_dir=save_dir,
            savefig=savefig,
            spin=spin,sub_orb=sub_orb
        )
    elif pt == 'dos':
        plot_dos(dos_file, fermi_level, shift_fermi, y_range, x_range=x_range, dpi=dpi,
        save_dir=save_dir, savefig=savefig, vertical=vertical)
    elif plot_type == 'overlay_band':
        overlay_band_plot(
            band_file, kpath_file,
            band_file2, kpath_file2,
            fermi_level=fermi_level,
            shift_fermi=shift_fermi,
            y_range=y_range,
            dpi=dpi,
            color1=color1,
            color2=color2,
            label1=label1,
            label2=label2,
            save_dir=save_dir,
            savefig=savefig
        )

    elif pt == 'pdos':
        plot_pdos_dir(pdos_dir, fermi_level, shift_fermi, y_range, dpi=dpi,pdos_mode=pdos_mode,
        save_dir=save_dir, savefig=savefig)
    elif pt == 'fatbands':
        fb_dir = fatband_dir if fatband_dir is not None else pdos_dir
        if fb_dir is None or band_file is None or kpath_file is None:
            raise ValueError("fatband_dir (or file_path), band_file, and kpath_file are all required for 'fatbands'")
        plot_fatbands(
            fatband_dir=fb_dir,
            kpath_file=kpath_file,
            band_file=band_file,
            mode=fatbands_mode,
            highlight_channel=highlight_channel,
            dual=dual,
            fermi_level=fermi_level,
            shift_fermi=shift_fermi,
            y_range=y_range,
            cmap_name=cmap_name,
            s_min=s_min,
            s_max=s_max,
            weight_threshold=weight_threshold,
            plot_total_dos=plot_total_dos,
            dos_file=dos_file,
            overlay_bands_in_heat=overlay_bands_in_heat,
            heat_vmin=heat_vmin,
            heat_vmax=heat_vmax,
            dpi=dpi,
            layer_assignment=layer_assignment,
            save_dir=save_dir,
            savefig=savefig,
            spin=spin,
            sub_orb=sub_orb# <--- PASSED DOWN
        )
    else:
        raise ValueError("Use 'band','dos','pdos', or 'fatbands' for plot_type")





#================================================================#


#Band gab dedector



#================================================================#



from pathlib import Path
import numpy as np
import re


def parse_kpoints_crystal_b(kpt_file):
    lines = Path(kpt_file).read_text().splitlines()
    for i, ln in enumerate(lines):
        if ln.strip().startswith('K_POINTS'):
            break
    lines = lines[i + 2:]
    weights, labels = [], []
    pat = re.compile(r"!(\S+)")
    for ln in lines:
        ln = ln.strip()
        if not ln:
            break
        parts = ln.split()
        weights.append(int(parts[3]))
        m = pat.search(ln)
        labels.append(m.group(1) if m else f"pt{len(labels)}")
    edges = [0]
    for w in weights:
        edges.append(edges[-1] + w)
    return weights, labels, edges


def parse_bandgnu_blocks(band_file):
    """
    Parses a QE 'bands.dat.gnu' file into K-distance and Energy arrays.

    Parameters
    ----------
    band_file : str
        Path to the .gnu band file.

    Returns
    -------
    kdist : np.ndarray
        Array of shape (Nk,) containing k-point distances.
    E : np.ndarray
        Array of shape (Nk, Nb) containing band energies.
    """
    lines = Path(band_file).read_text().splitlines()
    blocks, curr = [], []
    for ln in lines:
        if not ln.strip():
            if curr:
                blocks.append(curr)
                curr = []
        else:
            curr.append(ln)
    if curr:
        blocks.append(curr)
    nk, nb = len(blocks[0]), len(blocks)
    kdist = np.zeros(nk)
    E = np.zeros((nk, nb))
    for b, blk in enumerate(blocks):
        if len(blk) != nk:
            raise ValueError(f"Band {b} has {len(blk)} pts, expected {nk}")
        for i, ln in enumerate(blk):
            p = ln.split()
            if b == 0:
                kdist[i] = float(p[0])
            E[i, b] = float(p[1])
    return kdist, E


def segment_for_index(idx, edges, labels):
    for i in range(len(edges)):
        if idx == edges[i]:
            return labels[i] if i < len(labels) else f"pt{i}"
        if i < len(edges) - 1 and edges[i] < idx < edges[i + 1]:
            return f"{labels[i]}–{labels[i + 1]}"
    return "?"


def detect_band_gap(band_file, kpt_file, fermi_level=None):
    """
    Analyzes the band structure to detect VBM, CBM, and Band Gap.

    Parameters
    ----------
    band_file : str
        Path to the .gnu band file.
    kpt_file : str
        Path to the K-path file used to generate bands.
    fermi_level : float, optional
        Fermi energy in eV. If None, it estimates it as mid-gap.

    Returns
    -------
    None
        Prints the VBM, CBM, gap size, and direct/indirect nature to stdout.
    """
    kdist, E = parse_bandgnu_blocks(band_file)
    weights, labels, edges = parse_kpoints_crystal_b(kpt_file)

    if fermi_level is None:
        vbm = np.max(E)
        cbm_candidates = E[E > vbm + 1e-6]
        if cbm_candidates.size == 0:
            return "ERROR: No CBM found above VBM."
        cbm = np.min(cbm_candidates)
        gap = cbm - vbm
        fermi_level = 0.5 * (vbm + cbm)
    else:
        E_rel = E - fermi_level
        vbm = np.max(E[E_rel <= 1e-7])
        cbm = np.min(E[E_rel > 0])
        gap = cbm - vbm

    vbm_idx = np.argwhere(np.isclose(E, vbm)).tolist()[0]
    cbm_idx = np.argwhere(np.isclose(E, cbm)).tolist()[0]
    kv, bv = vbm_idx
    kc, bc = cbm_idx

    is_direct = (kv == kc)

    seg_v = segment_for_index(kv, edges, labels)
    seg_c = segment_for_index(kc, edges, labels)

    result = f"{Path(band_file).stem}: Gap={gap:.3f} eV at Fermi={fermi_level:.3f} eV ({'direct' if is_direct else 'indirect'})\n"
    result += f"  VBM: E={vbm:.3f} eV (kpt {kv}, band {bv}, {seg_v})\n"
    result += f"  CBM: E={cbm:.3f} eV (kpt {kc}, band {bc}, {seg_c})\n"
    if not is_direct:
        result += f"  Indirect: VBM at {seg_v}, CBM at {seg_c}\n"

    print(result)

#================================================================#


#Bilayer_analyezer



#================================================================#


import re
from collections import Counter
from itertools import combinations
from pathlib import Path
from typing import List, Sequence, Tuple, Union
import numpy as np

BOHR_TO_ANGSTROM = 0.529177
PLANAR_TOL = 0.25
SHIFT_TOL  = 0.12
_A1 = np.array([0.5, -np.sqrt(3)/2, 0.0])
_A2 = np.array([0.5,  np.sqrt(3)/2, 0.0])
_A3 = np.array([0.0,   0.0,       1.0])

def gather_blocks(text: str) -> List[Tuple[str, List[str]]]:
    blocks = []
    current: List[str] = []
    label = None
    auto = 1
    for line in text.splitlines():
        m = re.match(r'^\s*>>>\s*(\S+)', line)
        if m:
            if current and any(s.strip() for s in current):
                blocks.append((label if label else str(auto), current))
                auto += 1
            label = m.group(1)
            current = []
        else:
            current.append(line)
    if current and any(s.strip() for s in current):
        blocks.append((label if label else str(auto), current))
    return blocks

# ---------- QE PARSER ---------- #
def parse_qe_block(lines: Sequence[str]) -> Tuple[np.ndarray, List[str], np.ndarray]:
    ibrav = None
    celldm = {}
    cell_parameters = None
    cell_units  = 'alat'
    atpos_units = 'alat'
    species, coords = [], []

    for ln in lines:
        m = re.search(r'\bibrav\s*=\s*(-?\d+)', ln, re.I)
        if m: ibrav = int(m.group(1))
        for k in range(1,7):
            mk = re.search(rf'celldm\({k}\)\s*=\s*([0-9.eE+-]+)', ln, re.I)
            if mk: celldm[k] = float(mk.group(1))

    # CELL_PARAMETERS
    for i, ln in enumerate(lines):
        if "CELL_PARAMETERS" in ln.upper():
            m = re.search(r'cell_parameters\s*\{?(\w+)?\}?', ln, re.I)
            if m and m.group(1): cell_units = m.group(1).lower()
            mat = [list(map(float, lines[j].split()[:3])) for j in range(i+1, i+4)]
            cell_parameters = np.array(mat)
            break

    # ATOMIC_POSITIONS
    at_start = None
    for i, ln in enumerate(lines):
        if "ATOMIC_POSITIONS" in ln.upper():
            m = re.search(r'atomic_positions\s*\{?(\w+)?\}?', ln, re.I)
            if m and m.group(1): atpos_units = m.group(1).lower()
            at_start = i+1
            break

    if at_start is not None:
        for ln in lines[at_start:]:
            t = ln.strip()
            if not t: continue
            if (t.startswith('K_POINTS') or t.startswith('CELL_PARAMETERS') or
                t.startswith('ATOMIC_SPECIES') or t.startswith('/') or t.startswith('&')):
                break
            toks = t.split()
            if len(toks) < 4: continue
            sp, x, y, z = toks[:4]
            species.append(sp)
            coords.append([float(x), float(y), float(z)])
    coords = np.array(coords)

    if len(species) == 0:
        return None, [], np.zeros((0,3))

    # cell
    if cell_parameters is not None:
        cell = cell_parameters.copy()
        if cell_units == 'alat':
            if 1 not in celldm:
                raise ValueError("CELL_PARAMETERS {alat} var ama celldm(1) yok!")
            cell *= celldm[1] * BOHR_TO_ANGSTROM
        elif cell_units == 'bohr':
            cell *= BOHR_TO_ANGSTROM
    else:
        if ibrav is None:
            ibrav = _guess_ibrav_from_celldm(celldm)
            if ibrav is None:
                raise ValueError("Ne CELL_PARAMETERS var ne ibrav! (celldm kombinasyonu da yetersiz)")
        cell = ibrav2cell(ibrav, celldm)

    # frac
    if atpos_units in ('crystal','crystal_sg','alat'):
        frac = coords
    elif atpos_units == 'bohr':
        cart = coords * BOHR_TO_ANGSTROM
        frac = cart @ np.linalg.inv(cell)
    elif atpos_units == 'angstrom':
        cart = coords
        frac = cart @ np.linalg.inv(cell)
    elif atpos_units == 'cartesian':
        # eğer CELL_PARAMETERS yoksa ölçek tahmini:
        if cell_parameters is None and '1' in celldm and cell_units == 'alat':
            cart = coords * celldm.get(1,1.0) * BOHR_TO_ANGSTROM
        elif cell_parameters is None and cell_units == 'bohr':
            cart = coords * BOHR_TO_ANGSTROM
        else:
            cart = coords
        frac = cart @ np.linalg.inv(cell)
    else:
        raise ValueError(f"Desteklenmeyen ATOMIC_POSITIONS birimi: {atpos_units}")

    return cell, species, frac

def _guess_ibrav_from_celldm(cd: dict) -> Union[int,None]:
    """celldm kombinasyonundan olası ibrav tahmini."""
    if 1 in cd and 3 in cd and len(cd)==2:
        return 4  # hex
    if 1 in cd and 2 in cd and 3 in cd and len(cd)==3:
        return 8  # simple orthorhombic
    if 1 in cd and len(cd)==1:
        return 1  # cubic
    # daha fazlasını istersen ekle
    return None

def ibrav2cell(ibrav: int, cd: dict) -> np.ndarray:
    a = cd.get(1, 1.0)
    if   ibrav == 1:  cell = np.eye(3)*a
    elif ibrav == 2:  cell = a*np.array([[0,0.5,0.5],[0.5,0,0.5],[0.5,0.5,0]])
    elif ibrav == 3:  cell = a*np.array([[-0.5,0.5,0.5],[0.5,-0.5,0.5],[0.5,0.5,-0.5]])
    elif ibrav == 4:
        c = a*cd[3]
        cell = np.array([[0.5*a,-np.sqrt(3)/2*a,0],[0.5*a,np.sqrt(3)/2*a,0],[0,0,c]])
    elif ibrav == 5:
        alpha = np.arccos(cd[4])
        v = a*np.array([np.sin(alpha),0,np.cos(alpha)])
        cell = np.vstack([v, np.roll(v,1), np.roll(v,2)])
    elif ibrav == 6:
        cell = np.diag([a,a,a*cd[3]])
    elif ibrav == 7:
        c = a*cd[3]
        cell = np.array([[ a/2,-a/2, c/2],[ a/2, a/2, c/2],[-a/2,-a/2, c/2]])
    elif ibrav == 8:
        cell = np.diag([a,a*cd[2],a*cd[3]])
    elif ibrav == 9:
        b,c = a*cd[2], a*cd[3]
        cell = np.array([[a,0,0],[0,b,0],[a/2,b/2,c]])
    elif ibrav == 10:
        b,c = a*cd[2], a*cd[3]
        cell = np.array([[0,b/2,c/2],[a/2,0,c/2],[a/2,b/2,0]])
    elif ibrav == 11:
        b,c = a*cd[2], a*cd[3]
        cell = np.array([[a/2,b/2,c/2],[-a/2,b/2,c/2],[0,-b/2,c/2]])
    elif ibrav == 12:
        b,c = a*cd[2], a*cd[3]; beta = cd[4]
        cell = np.array([[a,0,0],[0,b,0],[c*np.cos(beta),0,c*np.sin(beta)]])
    elif ibrav == 13:
        b,c = a*cd[2], a*cd[3]; beta = cd[4]
        cell = np.array([[a/2,-b/2,0],[a/2,b/2,0],[c*np.cos(beta),0,c*np.sin(beta)]])
    elif ibrav == 14:
        b,c = a*cd[2], a*cd[3]; cosb,cosa,cosg = cd[4], cd[5], cd[6]
        sing = np.sqrt(1-cosg**2)
        cell = np.array([[a,0,0],
                         [b*cosg, b*sing, 0],
                         [c*cosa, c*(cosb-cosa*cosg)/sing,
                          c*np.sqrt(1-cosa**2-((cosb-cosa*cosg)/sing)**2)]])
    else:
        raise ValueError(f"ibrav={ibrav} tanımlı değil.")
    return cell*BOHR_TO_ANGSTROM


def cart_from_frac(cell: np.ndarray, frac: np.ndarray) -> np.ndarray:
    return frac @ cell

def compute_all_z_distances(cart: np.ndarray):
    for i,j in combinations(range(len(cart)),2):
        yield i,j,abs(cart[j,2]-cart[i,2])

def compute_all_distances(cart: np.ndarray):
    for i,j in combinations(range(len(cart)),2):
        yield i,j,float(np.linalg.norm(cart[j]-cart[i]))

def split_layers(frac: np.ndarray) -> Tuple[List[int], List[int]]:
    if len(frac)==0: return [],[]
    z = frac[:,2]
    order = np.argsort(z)
    gaps  = np.diff(z[order])
    if len(gaps)==0: return list(range(len(frac))), []
    k   = np.argmax(gaps)+1
    thr = (z[order][k-1]+z[order][k])/2
    lower = [i for i,v in enumerate(z) if v<=thr]
    upper = [i for i,v in enumerate(z) if v> thr]
    return lower, upper

def custom_labeling(species: List[str]) -> List[str]:
    cnt, labels = {}, []
    for s in species:
        cnt[s]=cnt.get(s,0)+1
        labels.append(f"{s}{cnt[s]}")
    return labels

def classify_stacking(cell: np.ndarray, species: List[str], frac: np.ndarray) -> str:
    if len(frac)==0: return "NO_ATOMS"
    metal = min(Counter(species), key=species.count)
    lower, upper = split_layers(frac)
    cart = cart_from_frac(cell, frac)
    pairs=set()
    for i in upper:
        for j in lower:
            d = cart[i]-cart[j]; d[2]=0
            if np.linalg.norm(d)<PLANAR_TOL:
                pairs.add((species[i]==metal, species[j]==metal))
    mm = any(pi and pj for pi,pj in pairs)
    xx = any((not pi) and (not pj) for pi,pj in pairs)
    mx = any(pi and (not pj) for pi,pj in pairs)
    xm = any((not pi) and pj for pi,pj in pairs)
    if mx and xm: return 'AA′'
    if xx and not(mm or mx or xm): return 'A′B'
    if xm and not(mm or mx or xx): return 'AB'
    if mm and not(xx or mx or xm): return 'AB′'
    disp=[]
    for i in upper:
        if species[i]!=metal: continue
        dv = frac[lower,:2]-frac[i,:2]; dv -= np.round(dv)
        disp.append(dv[np.argmin(np.linalg.norm(dv,axis=1))])
    if not disp: return 'AA'
    Δ = np.mod(np.mean(disp,axis=0),1)
    CANON={"AA":np.array([0,0]),"AB":np.array([1/3,2/3]),"AB′":np.array([2/3,1/3])}
    name,dist=min(((k,np.linalg.norm(Δ-v)) for k,v in CANON.items()), key=lambda x:x[1])
    return name if dist<SHIFT_TOL else "AA"


def analyse_file(path: Union[str, Path]):
    """
    Analyzes a Quantum ESPRESSO input/output file structure.
    Determines lattice parameters, stacking sequence (for 2D), and interlayer distances.

    Parameters
    ----------
    path : str or Path
        Path to the QE input (.in) or output (.out) file.

    Returns
    -------
    None
        Prints structure statistics to stdout.
    """
    text = Path(path).read_text()
    blocks = gather_blocks(text)
    for tag, blk in blocks:
        try:
            cell, species, frac = parse_qe_block(blk)
            if len(species)==0:
                print(f"[{tag}] EMPTY BLOCK, SKIPPED.")
                continue
        except Exception as e:
            print(f"[{tag}] ERROR: {e}")
            continue

        cart = cart_from_frac(cell, frac)
        a, c = np.linalg.norm(cell[0]), np.linalg.norm(cell[2])
        stacking = classify_stacking(cell, species, frac)
        labels   = custom_labeling(species)

        print("="*40)
        print(f"[{tag}]  a={a:.3f} Å  c={c:.3f} Å  → stacking: {stacking}")
        print("-"*40)
        print("All ΔZ (vertical) distances (Å):")
        for i,j,dz in compute_all_z_distances(cart):
            print(f"  {labels[i]}-{labels[j]}: {dz:.3f}")
        print("\nAll 3D distances (Å):")
        for i,j,d in compute_all_distances(cart):
            print(f"  {labels[i]}-{labels[j]}: {d:.3f}")
        print()



#===================================================================


#cONVERTOR FROM PROJ.OUT TO FATBANDS FILE



#================================================================#

import pathlib, re
from collections import defaultdict
from typing import Dict, List, Tuple, IO, Generator

# ---------------------------------------------------------------------------
# 1.  Parse the “state # …” table (maps global‑idx → atom / wfc / j / m_j)
# ---------------------------------------------------------------------------
_STATE_RX = re.compile(
    r"state #\s*(\d+):\s*atom\s*(\d+)\s*\(\s*([A-Za-z]+)\s*\)"
    r"\s*,\s*wfc\s*(\d+)\s*\(l=(\d+)\s+j=([0-9.]+)\s+m_j=\s*([-\d.]+)\)"
)

IdxInfo   = Dict[str, Union[int, float, str]]
GroupKey  = Tuple[int, str, int, int, float]       # (atom, elem, wfc, l, j)


def _parse_state_table(text: str) -> Tuple[Dict[int, IdxInfo], Dict[GroupKey, List[int]]]:
    spin_orbit_coupled = "j=" in text

    if spin_orbit_coupled:
        state_rx = re.compile(
            r"state #\s*(\d+):\s*atom\s*(\d+)\s*\(\s*([A-Za-z]+)\s*\)"
            r"\s*,\s*wfc\s*(\d+)\s*\(l=(\d+)\s+j=([0-9.]+)\s+m_j=\s*([-\d.]+)\)"
        )
    else:
        state_rx = re.compile(
            r"state #\s*(\d+):\s*atom\s*(\d+)\s*\(\s*([A-Za-z]+)\s*\)\s*,\s*"
            r"wfc\s*(\d+)\s*\(l=(\d+)\s*m=\s*\d+\)"
        )

    idx2info: Dict[int, IdxInfo] = {}
    group2idx: Dict[Tuple, List[Tuple[float, int]]] = defaultdict(list)

    for line in text.splitlines():
        m = state_rx.search(line)
        if not m:
            continue

        if spin_orbit_coupled:
            gidx, atom, elem, wfc, l, j, mj = m.groups()
            gidx, atom, wfc, l = map(int, (gidx, atom, wfc, l))
            j, mj = float(j), float(mj)
            info = dict(atom=atom, elem=elem.strip(), wfc=wfc, l=l, j=j, mj=mj)
            key = (atom, elem.strip(), wfc, l, j)
            group2idx[key].append((mj, gidx))
        else:
            gidx, atom, elem, wfc, l = m.groups()
            gidx, atom, wfc, l = map(int, (gidx, atom, wfc, l))
            info = dict(atom=atom, elem=elem.strip(), wfc=wfc, l=l)
            key = (atom, elem.strip(), wfc, l)
            group2idx[key].append((0.0, gidx))  # dummy m_j

        idx2info[int(gidx)] = info

    group_sorted: Dict[Tuple, List[int]] = {}
    for key, lst in group2idx.items():
        lst.sort(key=lambda t: t[0])
        group_sorted[key] = [g for _, g in lst]

    return idx2info, group_sorted



# ---------------------------------------------------------------------------
# 2.  Walk through k‑points / bands and collect |c|² weights
# ---------------------------------------------------------------------------
_K_RX      = re.compile(r"^\s*k\s*=\s*[0-9.eE+\-]+\s+[0-9.eE+\-]+\s+[0-9.eE+\-]+")
_ENERGY_RX = re.compile(r"====\s*e\(\s*\d+\)\s*=\s*([-\d.Ee+]+)\s*eV")
_COEFF_RX  = re.compile(r"([0-9.]+)\*\[\#\s*([0-9]+)\]")


def _stream_states(fh: IO[str]) -> Generator[Tuple[int, float, Dict[int, float]], None, None]:
    """Yield (ik, energy_eV, {global_idx: |c|², …}) for every band."""
    ik = 0
    collecting = False
    current_E  = None
    current_w  = defaultdict(float)

    for line in fh:
        if _K_RX.match(line):
            # flush last band of previous k‑point
            if collecting and current_E is not None:
                yield ik, current_E, current_w
                collecting, current_E = False, None
                current_w = defaultdict(float)
            ik += 1
            continue

        mE = _ENERGY_RX.match(line)
        if mE:
            if collecting and current_E is not None:          # flush previous
                yield ik, current_E, current_w
            current_E  = float(mE.group(1))
            current_w  = defaultdict(float)
            collecting = True
            continue

        if collecting:
            for amp, idx in _COEFF_RX.findall(line):
                current_w[int(idx)] += float(amp) ** 2

    # flush very last band
    if collecting and current_E is not None:
        yield ik, current_E, current_w


# ---------------------------------------------------------------------------
# 3.  Utility for filenames
# ---------------------------------------------------------------------------
_L2SYM = {0: "s", 1: "p", 2: "d", 3: "f", 4: "g"}
def _orb_sym(l: int) -> str:
    return _L2SYM.get(l, f"l{l}")


def _make_filename(outdir: pathlib.Path, key: Tuple) -> pathlib.Path:
    atom, elem, wfc, l = key[:4]  # her zaman bu dördü var
    j = key[4] if len(key) > 4 else None  # j varsa al, yoksa None

    if j is not None:
        jstr = f"{j:.1f}".rstrip("0").rstrip(".")
        filename = f"fatbands.pdos_atm#{atom}({elem})_wfc#{wfc}({_orb_sym(l)}_j{jstr})"
    else:
        filename = f"fatbands.pdos_atm#{atom}({elem})_wfc#{wfc}({_orb_sym(l)})"

    return outdir / filename



# ---------------------------------------------------------------------------
# 4.  Public API
# ---------------------------------------------------------------------------
def convert_consistent(proj_out: Union[str, pathlib.Path],
                       outdir: Union[str, pathlib.Path] = "BMS_pdos",
                       *,
                       overwrite: bool = True,
                       verbose: bool = True) -> None:
    """
    Standardizes 'projwfc' output files for plotting.
    
    This function reads a raw QE projwfc output file and generates separate 
    fatband files for each orbital group, ensuring consistent row counts per k-point.
    It resolves issues where 'projwfc.x' outputs a varying number of lines 
    depending on the projection weight.

    Parameters
    ----------
    proj_out : str or Path
        Path to the 'proj.out' or 'pdos.out' file generated by projwfc.x.
    outdir : str or Path, optional
        Target directory to save the cleaned .pdos files. Default is "BMS_pdos".
    overwrite : bool
        If True, overwrites existing files in `outdir`.
    verbose : bool
        If True, prints progress to stdout.
    """
    proj_out = pathlib.Path(proj_out)
    outdir   = pathlib.Path(outdir)
    outdir.mkdir(parents=True, exist_ok=True)

    text = proj_out.read_text(errors="ignore")
    idx2info, group2idx = _parse_state_table(text)
    all_groups = list(group2idx)                    # fixed order

    # open one file per group and write headers
    open_files: Dict[GroupKey, Tuple[IO[str], List[int]]] = {}
    for key in all_groups:
        path = _make_filename(outdir, key)
        if path.exists() and not overwrite:
            raise FileExistsError(path)
        fh = path.open("w")
        idx_list = group2idx[key]
        header = "# ik    E (eV)   ldos(E)" + "".join(
            f"   pdos(E)_{i+1}" for i in range(len(idx_list))
        ) + "\n"
        fh.write(header)
        open_files[key] = (fh, idx_list)

    # stream states
    with proj_out.open("r", errors="ignore") as fh:
        for ik, E, weights in _stream_states(fh):
            # initialise zeros
            ldos = {k: 0.0 for k in all_groups}
            cols = {k: [0.0] * len(group2idx[k]) for k in all_groups}

            # fill weights we have
            for gidx, w in weights.items():
                info = idx2info[gidx]
                if "j" in info:
                    key = (info["atom"], info["elem"], info["wfc"], info["l"], info["j"])
                else:
                    key = (info["atom"], info["elem"], info["wfc"], info["l"])

                col  = group2idx[key].index(gidx)
                ldos[key]         += w
                cols[key][col]     = w

            # write one row per group
            for key in all_groups:
                fh_out, _ = open_files[key]
                row = f"{ik:4d}  {E:10.5f}  {ldos[key]:.6e}" + "".join(
                      f"  {c:.6e}" for c in cols[key]) + "\n"
                fh_out.write(row)

            if verbose and ik % 10 == 0:
                print(f"Processed k‑point {ik}", end="\r")

    # close files
    for fh, _ in open_files.values():
        fh.close()
    if verbose:
        print(f"\nDone – wrote {len(open_files)} projector files to '{outdir}'.")


        #================================================================
        #soc converter

        #=================================================================
# -*- coding: utf-8 -*-
r"""
soc2ml.py  –  Re‑project Quantum‑ESPRESSO *projwfc* ``proj.out`` files that include
spin–orbit coupling (SOC) onto the usual \((\ell,m_{\ell})\) basis and **write one
fatbands/PDOS‑style file per (atom, wfc, \ell)** exactly like QE does in the
scalar‑relativistic case, e.g.

```
fatbands.pdos_atm#1(Mo)_wfc#3(d)
```

Each output file contains *one* column for the total local DOS of that projector
and *2\ell+1* ``pdos(E)_k`` columns – one for every \(m_{\ell}=-\ell,\dots,\ell\).
The first column is always the sum of the others, so downstream tools (gnuplot,
pyprocar, sumo, …) will work exactly as before.

---------------  Quick use  ---------------
>>> from soc2ml import convert_soc_proj_to_ml
>>> convert_soc_proj_to_ml("proj.out", outdir="MLM_pdos")

----------------------------------------------------------------------
"""
# -*- coding: utf-8 -*-
"""
soc2ml.py  –  Convert Quantum‑ESPRESSO *projwfc* ``proj.out`` that were run
with spin–orbit coupling so that you obtain ordinary fatbands / PDOS files in the
(ℓ, mₗ) basis — identical naming to scalar‑relativistic QE output, e.g.

    fatbands.pdos_atm#1(Mo)_wfc#3(d)

Each file has the standard layout

    ik   E(eV)   ldos(E)   pdos(E)_1 … pdos(E)_(2ℓ+1)

where ``ldos(E)`` is the sum over the 2ℓ+1 mₗ columns.  Works with gnuplot,
pyprocar, sumo and similar tools out‑of‑the‑box.

---------------------------------------------------------------------
Quick use
---------------------------------------------------------------------
>>> from soc2ml import convert_soc_proj_to_ml
>>> convert_soc_proj_to_ml("projwfc.out", outdir="MLM_pdos")
---------------------------------------------------------------------


"""

import pathlib
import re
from collections import defaultdict
from typing import Dict, List, Tuple, IO, Generator

# -----------------------------------------------------------------------------
# 0.  Clebsch–Gordan helper using *sympy*
# -----------------------------------------------------------------------------
# simple memoisation because the same (l,j,mj,ml) pairs repeat a lot
_CG_CACHE: Dict[Tuple[int, float, float, int], float] = {}

def _cg_prob(l: int, j: float, mj: float, ml: int) -> float:
    """Return  ∑_{m_s=±½} |⟨l ml;½ m_s | l j m_j⟩|²  (Clebsch–Gordan)."""
    # Lazy import to avoid hard dependency on sympy
    from sympy.physics.wigner import clebsch_gordan as _CG
    from sympy import Rational as _R

    prob = 0.0
    for m_s in (-0.5, +0.5):
        if abs(ml - (mj - m_s)) < 1e-8:            # selection rule
            prob += float(_CG(l, _R(1, 2), j, ml, m_s, mj) ** 2)
    return prob

def _cg_cached(l: int, j: float, mj: float, ml: int) -> float:
    key = (l, j, mj, ml)
    if key not in _CG_CACHE:
        _CG_CACHE[key] = _cg_prob(l, j, mj, ml)
    return _CG_CACHE[key]

# -----------------------------------------------------------------------------
# 1.  Parse the “state # …” table  (global‑index → quantum numbers)
# -----------------------------------------------------------------------------
# Capture groups:  state, atom, element, wfc, l, j, mj   (= 7)
_RX_SOC = re.compile(
    r"state #\s*(\d+):\s*atom\s*(\d+)\s*\(\s*([A-Za-z]+)\s*\)\s*,\s*"
    r"wfc\s*(\d+)\s*\(l=(\d+)\s+j=([0-9./]+)\s+m_j=\s*([0-9.\-+/]+)\)"
)
# Capture groups:  state, atom, element, wfc, l, m  (= 6)
_RX_COL = re.compile(
    r"state #\s*(\d+):\s*atom\s*(\d+)\s*\(\s*([A-Za-z]+)\s*\)\s*,\s*"
    r"wfc\s*(\d+)\s*\(l=(\d+)\s*m=\s*(\d+)\)"
)

IdxInfo   = Dict[str, Union[int, float, str]]
GroupName = Tuple[int, str, int, int]   # atom, elem, wfc, l

def _parse_state_table(text: str) -> Tuple[Dict[int, IdxInfo], bool]:
    """Return (idx → info) and a boolean ‘is_soc’."""
    idx2info: Dict[int, IdxInfo] = {}
    is_soc = False

    for ln in text.splitlines():
        m = _RX_SOC.search(ln)
        if m:                                   # SOC entry
            g, atom, elem, wfc, l, j, mj = m.groups()
            idx2info[int(g)] = dict(atom=int(atom), elem=elem.strip(),
                                    wfc=int(wfc), l=int(l),
                                    j=float(eval(j)), mj=float(eval(mj)))
            is_soc = True
            continue
        m = _RX_COL.search(ln)                  # scalar‑rel. entry
        if m:
            g, atom, elem, wfc, l, mnum = m.groups()
            ml = int(mnum) - int(l) - 1         # QE’s (1…2l+1) → (‑l…+l)
            idx2info[int(g)] = dict(atom=int(atom), elem=elem.strip(),
                                    wfc=int(wfc), l=int(l), ml=ml)
    return idx2info, is_soc

# -----------------------------------------------------------------------------
# 2.  Iterate over k‑points / bands – collect |c|² weights
# -----------------------------------------------------------------------------
_K_RX = re.compile(r"^\s*k\s*=\s*[0-9.eE+\-]+\s+[0-9.eE+\-]+\s+[0-9.eE+\-]+")
_E_RX = re.compile(r"====\s*e\(\s*\d+\)\s*=\s*([\-0-9.Ee+]+)\s*eV")
_C_RX = re.compile(r"([0-9.]+)\*\[\#\s*(\d+)\]")

def _stream_states(fh: IO[str]) -> Generator[Tuple[int, float, Dict[int, float]], None, None]:
    """Yield  (ik, E_eV, {global_idx: |c|²})  for every band of every k‑point."""
    ik, collecting, E, W = 0, False, None, defaultdict(float)
    for ln in fh:
        if _K_RX.match(ln):                      # new k‑point
            if collecting and E is not None:
                yield ik, E, W
            ik, collecting, E, W = ik + 1, False, None, defaultdict(float)
            continue
        mE = _E_RX.match(ln)                    # new band
        if mE:
            if collecting and E is not None:
                yield ik, E, W
            E, collecting, W = float(mE.group(1)), True, defaultdict(float)
            continue
        if collecting:
            for amp, idx in _C_RX.findall(ln):
                W[int(idx)] += float(amp) ** 2
    if collecting and E is not None:
        yield ik, E, W

# -----------------------------------------------------------------------------
# 3.  User‑facing converter
# -----------------------------------------------------------------------------
_LSYM = {0: "s", 1: "p", 2: "d", 3: "f", 4: "g"}

def _orb(l: int) -> str:               # helper for filenames
    return _LSYM.get(l, f"l{l}")

def convert_soc_proj_to_ml(
    proj_out: Union[str, pathlib.Path],
    outdir: Union[str, pathlib.Path] = "MLM_pdos",
    *,
    overwrite: bool = True,
    quiet: bool = False,
) -> None:
    """
    Converts SOC (Spin-Orbit Coupling) 'projwfc' output to m-resolved PDOS files.

    In SOC calculations, projections are often given in (l, j, mj) basis. This function
    converts them to the standard (l, ml) basis using Clebsch-Gordan coefficients,
    summing up contributions to create standard s/p/d/f resolved files compatible 
    with standard plotting tools.

    Parameters
    ----------
    proj_out : str or Path
        Path to the SOC 'proj.out' file.
    outdir : str or Path, optional
        Target directory to save the converted files. Default is "MLM_pdos".
    overwrite : bool
        If True, overwrites existing files.
    quiet : bool
        If True, suppresses progress output.
    """
    proj_out = pathlib.Path(proj_out)
    outdir   = pathlib.Path(outdir)

    idx2info, is_soc = _parse_state_table(proj_out.read_text(errors="ignore"))
    if not is_soc:
        if not quiet:
            print("[soc2ml]  File appears scalar‑relativistic – nothing to do.")
        return

    # ------------------------------------------------------------------
    # prepare one output handle per (atom, elem, wfc, l)
    # ------------------------------------------------------------------
    outdir.mkdir(parents=True, exist_ok=True)
    fhs: Dict[GroupName, IO[str]] = {}
    for inf in idx2info.values():
        key = (inf["atom"], inf["elem"], inf["wfc"], inf["l"])
        if key in fhs:
            continue
        atom, el, wfc, l = key
        fname = f"fatbands.pdos_atm#{atom}({el})_wfc#{wfc}({_orb(l)})"
        path  = outdir / fname
        if path.exists() and not overwrite:
            raise FileExistsError(path)
        cols   = 2 * l + 1
        header = "# ik    E (eV)   ldos(E)" + "".join(
            f"   pdos(E)_{i+1}" for i in range(cols)
        ) + "\n"
        fh = path.open("w"); fh.write(header); fhs[key] = fh

    # map ml → column index per l once
    ml_idx = {l: {ml: ml + l for ml in range(-l, l + 1)}
              for l in {inf['l'] for inf in idx2info.values()}}

    # ------------------------------------------------------------------
    # stream states, distribute weights, write rows
    # ------------------------------------------------------------------
    with proj_out.open("r", errors="ignore") as fh_in:
        for ik, E, W in _stream_states(fh_in):
            ldos_row: Dict[GroupName, float] = defaultdict(float)
            pdos_row: Dict[GroupName, List[float]] = {}

            for gidx, w in W.items():
                inf = idx2info[gidx]; l = inf["l"]
                key = (inf["atom"], inf["elem"], inf["wfc"], l)
                if key not in pdos_row:
                    pdos_row[key] = [0.0] * (2 * l + 1)
                j, mj = inf["j"], inf["mj"]
                for ml in range(-l, l + 1):
                    p = _cg_cached(l, j, mj, ml)
                    if p:
                        idx = ml_idx[l][ml]
                        pdos_row[key][idx] += w * p
                        ldos_row[key]      += w * p

            # write one line to every open file
            for key, fh in fhs.items():
                l_ = key[3]
                pdos_vals = pdos_row.get(key, [0.0] * (2 * l_ + 1))
                fh.write(
                    f"{ik:4d}  {E:12.6f}  {ldos_row[key]:.8e}" + "".join(
                        f"  {v:.8e}" for v in pdos_vals
                    ) + "\n"
                )

            if not quiet and ik % 10 == 0:
                print(f"[soc2ml]  k‑point {ik}", end="\r")

    for fh in fhs.values():
        fh.close()
    if not quiet:
        print(f"\n[soc2ml]  Wrote {len(fhs)} files → {outdir}")

def launch_gui():
    """
    Launches the QUI-Web Streamlit application.
    Assumes `qui_app.py` is in the same directory as this module.
    """
    import subprocess
    
    # Get directory of this file
    base_dir = os.path.dirname(os.path.abspath(__file__))
    app_path = os.path.join(base_dir, "qui_app.py")
    
    if not os.path.exists(app_path):
        print(f"Error: Could not find `qui_app.py` at {app_path}")
        return

    print(f"Launching QUI-Web from {app_path}...")
    try:
        # Run streamlit command
        subprocess.run(["streamlit", "run", app_path], check=True)
    except Exception as e:
        print(f"Failed to launch GUI: {e}")
        print("Try running manually: streamlit run qui_app.py")
